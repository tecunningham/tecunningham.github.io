---
title: "LLM Time-Saving, Demand Theory, and Task Activation"
author: "Tom Cunningham (METR)"
date: today
draft: true
citation: true
reference-location: document
bibliography: ai.bib
format:
  html:
    toc: true
    toc-depth: 3
execute:
  echo: false
  warning: false
  error: false
  cache: true
---

<!-- https://tecunningham.github.io/posts/2025-12-17-llm-time-saving-demand-theory-substitution.llm.html -->

<!-- Author note: review tools/test_llm_time_saving_qmd.py for tests and run it after edits. -->

```{python}
#| echo: false
#| results: asis
from __future__ import annotations

import subprocess
import sys
from pathlib import Path

from IPython.display import Markdown, display

# Quarto executes notebooks with a CWD that can differ from the repo root.
# Find the repo root by walking upward until we see both `tools/` and `posts/`.
repo_root: Path | None = None
for candidate in [Path.cwd(), *Path.cwd().parents]:
    if (candidate / "tools").is_dir() and (candidate / "posts").is_dir():
        repo_root = candidate
        break
if repo_root is None:
    repo_root = Path.cwd()

script_path = repo_root / "tools/test_llm_time_saving_qmd.py"

proc = subprocess.run(
    [sys.executable, str(script_path), "--no-llm"],
    capture_output=True,
    text=True,
    cwd=str(repo_root),
)
out = (proc.stdout or "").rstrip()
err = (proc.stderr or "").rstrip()
if not out and err:
    out = f"(stderr)\n{err}"
if proc.returncode != 0:
    out = f"[exit {proc.returncode}]\n{out}"

hide_lines = [
    "Programmatic: required sections present",
    "Programmatic: estimation flowchart present",
    "Programmatic: applications present",
    "Programmatic: experimental design present",
    "Programmatic: Mermaid renders via mermaid.ink (optional)",
]
filtered_lines: list[str] = []
for line in out.splitlines():
    if any(needle in line for needle in hide_lines):
        continue
    filtered_lines.append(line)
out = "\n".join(filtered_lines).strip()

md = (
    '<details class="validation-checklist">\n'
    "<summary>Validation Checks</summary>\n\n"
    "```text\n"
    f"{out}\n"
    "```\n"
    "</details>\n"
)
display(Markdown(md))
```

<style>
  dl {display: grid;}
  dt {grid-column-start: 1; width: 18em;}
  dd {grid-column-start: 2; margin-left: 1.25em;}
  details.validation-checklist {
    background: #f5f5f5;
    border: 1px solid #777;
    border-radius: 6px;
    padding: 0.5em 0.75em;
    margin-bottom: 1em;
  }
  details.validation-checklist > summary {
    cursor: pointer;
  }
</style>

<!--
Editing note: definition lists + multiline math

In Quarto, a definition list item starts with exactly one leading colon:

Term (a short claim)
: First paragraph of the definition.
  Continuation lines must be indented (e.g. two spaces).
  $$
  Multiline display math goes here.
  $$

Do NOT prefix continuation lines with additional ':' characters; that often breaks math rendering.
-->

## Results-first summary

**Speedups do not mechanically translate into aggregate productivity.**
: Once LLMs change the relative time costs of tasks, optimal time allocation changes, and the aggregate lift depends on substitution and (often) task activation.

**Overall lift is not pinned down by a share and a conditional speedup alone.**
: If tasks that get sped up initially take share $s$ of time and get speedup factor $A$ when you do them, then an arithmetic share calculation gives $1+s(A-1)$. That expression is correct only for a knife-edge estimand where you hold the task mix fixed. If you let the person reoptimize, $s$ is endogenous and the total lift depends on substitution.

**Allowing reallocation makes the estimand a time-allocation object.**
: Let $t=(t_1,\dots,t_n)$ be time allocated across tasks with $\sum_i t_i=1$. Let $A=(A_1,\dots,A_n)$ be task-specific productivity (effective output per unit time on each task). Let the output index be
  $$
  y(A_1 t_1,\dots,A_n t_n),
  $$
  where $y(\cdot)$ is increasing in each argument. The substitution-adjusted productivity level is
  $$
  V(A)\equiv \max_{t\ge 0}\; y(A_1 t_1,\dots,A_n t_n)\quad\text{s.t.}\quad \sum_i t_i\le 1.
  $$
  An LLM changes productivity from $A^0$ to $A^1$, and the lift is $V(A^1)/V(A^0)$.

**Substitutability governs how much time share moves when a task becomes cheap.**
: In a continuous model, if tasks are close substitutes then time shifts strongly toward the sped-up tasks and the aggregate lift can be much larger than $1+s(A-1)$. If tasks are strong complements, time shares are stable and the aggregate lift is closer to the share calculation. In parametric cases this is summarized by an elasticity; outside parametric cases it is a demand-curve object.

**Observing post-LLM shares can identify the elasticity in a CES benchmark.**
: In a two-good CES setting, observing both pre and post time shares for an AI-affected bundle, together with the relevant speedup, identifies the substitution elasticity via a logit-share formula. This makes post-LLM shares especially informative when you want a point estimate.

**With unit-demand task choice, you can bound the lift using pre and post task baskets.**
: If tasks are lumpy and you either do a task or not, and you observe the time required for each task pre and post AI, then you can bound the aggregate lift by evaluating the pre-AI chosen basket at post-AI time prices (a Laspeyres-style bound) and the post-AI chosen basket at post-AI time prices (a Paasche-style bound). The discrete section formalizes this.

## Setup: time allocation and task productivity

**The canonical setup is time allocation with task productivity.**
: You choose time shares $t=(t_1,\dots,t_n)$ with $\sum_i t_i=1$, and productivity enters as the vector $A=(A_1,\dots,A_n)$ in the output index $y(A_1 t_1,\dots,A_n t_n)$.

**Index-number results can be imported by reinterpreting productivity as inverse prices.**
: If you define a time price $p_i\equiv 1/A_i$ for an efficiency unit of task $i$, then changes in $A$ can be analyzed with standard expenditure-function and price-index tools. I use that equivalence in the continuous section because it is the cleanest way to import known results about exact indices, Tornqvist approximations, and compensated-demand integrals.

**Two margins matter.**
: The continuous model treats tasks as divisible and focuses on intensive reallocation. The discrete model treats the task set as lumpy (setup time or unit demand) and focuses on which tasks get activated.

**Continuous intensive margin means smooth substitution.**
: Choose time shares $t_i$ and allow interior reallocation.

**Discrete extensive margin means task activation and selection.**
: Choose which tasks to do at all (unit demand or setup costs).

**Separating the two margins keeps assumptions and data requirements explicit.**
: The logic, formulas, and data requirements diverge sharply between intensive reallocation and extensive-margin activation, so I treat them separately.

## Estimation cheat sheet

**This section maps measured productivity changes into a lift under common assumptions.**
: It is a lookup table for turning observed time changes or productivity multipliers into a substitution-adjusted lift $V(A^1)/V(A^0)$.

### Two-good reduction (AI-affected bundle vs the rest)

**A two-good reduction collapses tasks into an AI-affected bundle and the rest.**
: For back-of-envelope calculations, define two bundles: good 2 is the set of tasks whose productivity rises by a factor $A$ when AI is allowed, and good 1 is everything else (normalized). Let $s_0$ be the pre-AI time share on good 2, and suppose only good 2 gets the productivity multiplier $A>1$. Common benchmarks are:

| Assumption about substitution | Implied output gain $V(A^1)/V(A^0)$ | Notes |
|---|---|---|
| Perfect complements (Amdahl-style) | $\dfrac{1}{(1-s_0)+s_0/A}$ | Fixed proportions; AI only relaxes the bottleneck |
| Cobb-Douglas ($\varepsilon=1$) | $A^{s_0}$ | Share is constant; log change is $s_0\ln A$ |
| CES elasticity $\varepsilon$ | $\left((1-s_0)+s_0\,A^{\varepsilon-1}\right)^{\frac{1}{\varepsilon-1}}$ | Requires $\varepsilon$ (or enough data to infer it) |
| Perfect substitutes | $A$ | You can reallocate everything to the sped-up bundle |

**In the multi-task case, a Tornqvist/Divisia log-index is a convenient approximation.**
: A common approximation is
  $$
  \Delta\ln V \;\approx\; \sum_i \bar t_i\,\ln\left(\frac{A_i^1}{A_i^0}\right),\qquad \bar t_i \equiv \tfrac12(t_{i,0}+t_{i,1}),
  $$
  which uses average (pre/post) time shares (see @caves1982indexnumbers).

**Anthropic-style numbers span a wide range under different substitution assumptions.**
: If $s_0=0.10$ and $A=5$ (a 5x multiplier when AI is used), the implied gain depends heavily on the benchmark.

| Benchmark | Gain factor | Percent |
|---|---:|---:|
| Complements bound | $1/(0.9+0.02)\approx 1.087$ | $+8.7\\%$ |
| Cobb-Douglas | $5^{0.1}\approx 1.174$ | $+17.4\\%$ |
| CES, $\varepsilon=2$ | $0.9+0.1\\cdot 5 = 1.4$ | $+40\\%$ |
| Substitutes bound | $5$ | $+400\\%$ |

**The spread is the point.**
: Large conditional speedups do not translate to a unique aggregate lift without additional structure or data.

### If you observe pre and post time shares, you can infer an elasticity (in CES)

**In a two-good CES benchmark, post-AI shares identify the elasticity.**
: In the same two-good CES setting, let $s_1$ be the post-AI time share on good 2. Then
  $$
  \operatorname{logit}(s_1)-\operatorname{logit}(s_0)=(\varepsilon-1)\ln A,
  $$
  so
  $$
  \varepsilon \;=\; 1 + \frac{\operatorname{logit}(s_1)-\operatorname{logit}(s_0)}{\ln A}.
  $$
  Here $\operatorname{logit}(s)\equiv \ln\!\left(\frac{s}{1-s}\right)$.
  This is often the cleanest way to use both pre and post shares: estimate $\varepsilon$, then plug into the CES gain formula. If you do not believe CES globally, treat this as local to the observed price change.

### Estimation flowchart (what to do with your data)

```{mermaid}
flowchart TD
  A["Goal: estimate productivity lift<br/>V(A_new)/V(A_old)<br/>for fixed time endowment"] --> B{"Are tasks mostly divisible<br/>at the relevant margin?"}

  B -->|Yes: continuous| C{"Are speedups small<br/>or broad-based?"}
  C -->|Yes| D["Use share-weighted log changes:<br/>d ln V ~= sum_i t_i d ln A_i<br/>(Tornqvist/Divisia)"]
  C -->|No| E{"Do you have enough data to pin down substitution?<br/>e.g. CES elasticity, demand system"}
  E -->|Yes| F["Compute an exact/parametric index:<br/>map p_i=1/A_i; use e(p,1)<br/>CES closed form when applicable"]
  E -->|No| G["Trace a demand curve:<br/>vary effective AI cost/strength;<br/>estimate compensated shares; integrate"]

  B -->|No: setup or unit-demand| H["Model extensive margin:<br/>which tasks get activated?"]
  H --> I["Unit-demand tasks: bound the lift<br/>Laspeyres lower bound: pre-AI basket at post-AI time prices<br/>Paasche upper bound: post-AI basket at post-AI time prices"]
```

### What you can estimate with what data

| What you can measure | Recommended move | What you can credibly report |
|---|---|---|
| One big conditional multiplier $A$ + a baseline share $s_0$ | Report complements/substitutes bounds; add CES sensitivity | A wide interval for $V(A^1)/V(A^0)$ unless you assume $\varepsilon$ |
| Pre and post shares $(s_0,s_1)$ for an AI bundle + a multiplier $A$ | Use the logit formula to estimate $\varepsilon$; plug into CES gain | A model-based point estimate (local to the observed change) |
| Multiple randomized “AI price/quality” arms + observed shares | Estimate share response vs $\ln A$; integrate shares over the change | An “area under the (compensated) demand curve” estimate for large changes |
| Choice/activation data (tasks attempted) under multiple AI prices | Model activation thresholds / setup costs explicitly | Decomposition into intensive and extensive margins |

## Continuous (intensive-margin) model

**Homotheticity lets you treat productivity changes as inverse price changes.**
: Write effective task output as $z_i\equiv A_i t_i$. Then
  $$
  V(A)=\max_{z\ge 0}\; y(z)\quad\text{s.t.}\quad \sum_i \frac{z_i}{A_i}\le 1.
  $$
  Define time prices $p_i\equiv 1/A_i$. This turns the constraint into $\sum_i p_i z_i\le 1$, so standard expenditure-function and index-number results apply.
  In particular, define the unit-expenditure function $P(p)\equiv e(p,1)$. Under homotheticity, the productivity level is
  $$
  V(A)=\frac{1}{P(1/A)}.
  $$
  This is the classic index-number framing applied to time prices (see @caves1982indexnumbers).

**EV and CV translate productivity changes into welfare changes in time units.**
: Let $A^0\to A^1$ and define $p^k\equiv 1/A^k$. Equivalent and compensating variation (measured in time) are
  $$
  EV=e(p^0, V(A^1))-1,\qquad CV=e(p^1, V(A^0))-1.
  $$
  Under homotheticity,
  $$
  EV=\frac{P(p^0)}{P(p^1)}-1,\qquad CV=\frac{P(p^1)}{P(p^0)}-1,
  $$
  which is a clean way to translate time-saving into a welfare measure (see @hausman1981exact).

**Small changes admit a share-weighted approximation.**
: Let $t_i(A)$ denote optimal time shares. For small changes,
  $$
  d\ln V \;\approx\;\sum_i t_i(A)\,d\ln A_i.
  $$
  This is the time-allocation analog of share-weighted Hulten-style logic (see @hulten1978growth).

**Large changes require integrating compensated shares.**
: When gains are large, constant-elasticity shortcuts are dangerous. Using Hicksian (compensated) shares $s_i^H(p)$,
  $$
  d\ln P(p)=\sum_i s_i^H(p)\,d\ln p_i.
  $$
  For a single changing price (equivalently, a single changing productivity component),
  $$
  \ln\frac{P(p^1)}{P(p^0)}=\int s_2^H(p_2)\,d\ln p_2,
  $$
  i.e., exact welfare is an area-under-the-compensated-demand-curve object (see @willig1976consumerssurplus).

**CES yields closed-form formulas useful for back-of-envelope work.**
: For a CES aggregator in $z$,
  $$
  y(z)=\left(\sum_i \alpha_i z_i^{\frac{\sigma-1}{\sigma}}\right)^{\frac{\sigma}{\sigma-1}},\quad\sigma>0,
  $$
  the associated price index and (compensated) shares have closed form. In a two-good reduction where only good 2 gets a productivity multiplier $A$ and its ex-ante time share is $s_0$,
  $$
  \frac{V(A^1)}{V(A^0)}=\left((1-s_0)+s_0\,A^{\varepsilon-1}\right)^{\frac{1}{\varepsilon-1}},\qquad \varepsilon\equiv\sigma.
  $$
  This is the clean continuous benchmark (see @caves1982indexnumbers).

#### Two-good CES yields closed-form gain and share shift

**The output gain has a closed form in terms of $s_0,A,\varepsilon$.**
: In a two-good CES benchmark where only good 2 gets a multiplier $A$ (so $p_2'=p_2/A$),
  $$
  \frac{V(A^1)}{V(A^0)}=\left((1-s_0)+s_0\,A^{\varepsilon-1}\right)^{\frac{1}{\varepsilon-1}}.
  $$

**The post-AI share shift pins down $\varepsilon$ when $s_1$ is observed.**
: The post-AI time share is
  $$
  s_1=\frac{s_0\,A^{\varepsilon-1}}{(1-s_0)+s_0\,A^{\varepsilon-1}}
  \quad\Leftrightarrow\quad
  \operatorname{logit}(s_1)-\operatorname{logit}(s_0)=(\varepsilon-1)\ln A.
  $$

::: {.callout-note collapse="true"}
## Proof (structured)

1. *Given* CES unit-expenditure (time price) index
   $$
   P(p)=\left(\alpha_1^{\varepsilon}p_1^{1-\varepsilon}+\alpha_2^{\varepsilon}p_2^{1-\varepsilon}\right)^{\frac{1}{1-\varepsilon}},
   \qquad V(A)=\frac{1}{P(1/A)}.
   $$
2. *Let* $p_2' = p_2/A$ with $p_1$ fixed. Then
   $$
   \frac{V(A^1)}{V(A^0)}=\frac{P(p)}{P(p')}=
   \left(
     \frac{\alpha_1^{\varepsilon}p_1^{1-\varepsilon}+\alpha_2^{\varepsilon}p_2^{1-\varepsilon}}
          {\alpha_1^{\varepsilon}p_1^{1-\varepsilon}+\alpha_2^{\varepsilon}(p_2/A)^{1-\varepsilon}}
   \right)^{\frac{1}{\varepsilon-1}}.
   $$
3. *Define* the ex-ante share
   $$
   s_0\equiv\frac{\alpha_2^{\varepsilon}p_2^{1-\varepsilon}}
                  {\alpha_1^{\varepsilon}p_1^{1-\varepsilon}+\alpha_2^{\varepsilon}p_2^{1-\varepsilon}}.
   $$
   Substituting into Step 2 yields the claimed gain formula.
4. *For shares,* note CES time shares satisfy
   $$
   \frac{s}{1-s}=\frac{\alpha_2^{\varepsilon}p_2^{1-\varepsilon}}{\alpha_1^{\varepsilon}p_1^{1-\varepsilon}}.
   $$
   Therefore,
   $$
   \frac{s_1/(1-s_1)}{s_0/(1-s_0)}
   =
   \frac{(p_2')^{1-\varepsilon}}{p_2^{1-\varepsilon}}
   =
   \left(\frac{p_2/A}{p_2}\right)^{1-\varepsilon}
   =
   A^{\varepsilon-1},
   $$
   which rearranges to the stated closed form for $s_1$ and the logit identity.
5. QED.
:::

## Discrete (extensive-margin) model

**Task activation makes selection central.**
: The continuous model assumes you always do some of each task. That is wrong when tasks are lumpy, have setup costs, or are unit-demand. In those cases, LLMs can create newly affordable tasks, meaning the major effect is selection (which tasks get done at all), not intensive reallocation.

### Unit-demand formulation

**A unit-demand formulation treats tasks as lumpy goods.**
: Let each task have payoff $u_i$ and required time $w_i$, with decision $q_i\in\{0,1\}$. Then
  $$
  \max_{q\in\{0,1\}^n}\sum_i u_i q_i\quad\text{s.t.}\quad \sum_i w_i q_i\le 1.
  $$

**Productivity multipliers can turn tasks on at extensive-margin thresholds.**
: If AI multiplies productivity for task $i$ by $A_i$, and time required is inversely proportional to productivity, then $w_i$ falls to $w_i/A_i$. That change can turn tasks on once a threshold is crossed. This is the basic lumpy-choice phenomenon: tasks that were too time-expensive become attractive after AI. A CES elasticity is not a good summary statistic in this regime.

**Pre and post task baskets give Laspeyres and Paasche bounds on the lift.**
: Suppose you observe (i) the pre-AI chosen task vector $q^0$ and the post-AI chosen task vector $q^1$, and (ii) the per-task time requirements before and after AI, denoted $w_i^0$ and $w_i^1$. Define the time cost of a basket as $T^k(q)\equiv \sum_i w_i^k q_i$.
  Consider the fixed-basket lifts
  $$
  G_L \equiv \frac{T^0(q^0)}{T^1(q^0)} \qquad\text{and}\qquad
  G_P \equiv \frac{T^0(q^1)}{T^1(q^1)}.
  $$
  Under standard revealed-preference logic for a cost-of-living index (with time as the numeraire), the true time-price index lies between Paasche and Laspeyres, so the productivity lift lies between their inverses:
  $$
  G_L \;\le\; \frac{V(A^1)}{V(A^0)} \;\le\; G_P.
  $$
  Intuitively, $G_L$ is a conservative hold-the-old-basket-fixed estimate (lower bound), while $G_P$ allows both the basket and effective prices to shift (upper bound).

**Tasks with high "overhead shares" get larger effective multipliers.**
: A useful way to think about the tasks-you-previously-avoided condition is to decompose time cost into a baseline component plus an overhead component (search, reading, drafting, refactoring). For example, write
  $$
  w_i=a_i+b_i,
  $$
  and suppose AI primarily reduces overhead, $b_i' = b_i/A^{O}$ while $a_i$ is unchanged. Then
  $$
  w_i' = a_i + \frac{b_i}{A^{O}},\qquad
  A_i \equiv \frac{w_i}{w_i'} = \frac{a_i+b_i}{a_i+b_i/A^{O}},
  $$
  so $A_i$ is increasing in the overhead share $b_i/(a_i+b_i)$. Tasks you previously avoided plausibly have high overhead shares, so they get larger effective multipliers and are more likely to cross activation thresholds.

### Setup-cost variant (bridging discrete and continuous)

**Setup costs create lumpy activation even when within-task intensity is divisible.**
: Add a fixed setup time $\phi_i$ and allow continuous within-task time allocations:
$$
\max_{q,t}\; y(A_1 t_1,\dots,A_n t_n)\quad\text{s.t.}\quad \sum_i \phi_i q_i + \sum_i t_i \le 1,\; t_i=0\;\text{if }q_i=0.
$$

**With setup costs, large shocks mostly expand the active set.**
: If $\phi_i=0$, we recover the continuous model. If $\phi_i>0$, large productivity changes mostly expand the active set $\{i:q_i=1\}$, not the intensive shares.

### Worked example (discrete, not continuous)

**Discrete choice does not identify a single time-savings without more structure.**
: Suppose you can pick one task (unit demand). Task A yields value $u_A=10$ and takes 1 hour. Task B yields $u_B=12$ and takes 2 hours. Without LLMs you choose A. Now an LLM speeds up task B so it takes 1 hour, and you switch to B. The observed switch is consistent with a wide range of time-equivalent gains:

| Bound interpretation | Time-equivalent gain |
|---|---:|
| Upper bound (extra value worth a full hour) | 1 hour |
| Lower bound (extra value is only a small quality bump) | 0 hours |

**Selection effects require a model or bounds, not just observed switching.**
: The observed reallocation does not identify a precise time-savings without modeling discrete choice. This is why constant-elasticity summaries can be weak in the activation regime.

### Newly activated tasks

**Definition of newly activated tasks.**
: Call a task newly activated if you would not do it at baseline time prices but you do once its time cost drops.
  Examples include literature reviews you previously would not attempt, custom data visualizations, and long-form proofreading or refactoring.

**These show up as extensive-margin choices, not smooth intensities.**
: In a unit-demand or setup-cost model, these tasks show up as newly activated $q_i=1$ choices, not as marginal changes in time allocations. This is why AI share of time can jump even if underlying preferences are stable: the feasible set changed.

## Applications

### Application 1: from query-level time savings to an aggregate lift (Anthropic)

**Anthropic-style log studies estimate conditional time savings on observed AI conversations.**
: @anthropic2025estimatingproductivitygains estimates time savings from Claude conversations by comparing time required with vs without AI for a sample of tasks drawn from usage logs.

**Back-of-envelope inputs can be summarized as a baseline share and a productivity multiplier.**
: Illustratively, the inputs are:

| Quantity | Symbol | Value |
|---|---:|---:|
| Baseline time share on the AI-affected bundle | $s_0$ | $10\\%$ |
| Productivity multiplier when AI is used | $A$ | $5$ |

**Even in a two-good continuous approximation, the implied lift depends sharply on substitution.**
: The table below shows how different assumptions about substitutability map the same inputs into very different lifts.

| Assumption about substitution | What it means in this note | Assumption on $\varepsilon$ | Implied lift when $s_0=10\%$ and $A=5$ |
|---|---|---|---|
| Strong complements (Amdahl/Leontief-style) | Time shares do not move much when a subset of tasks speeds up | effectively $\varepsilon\to 0$ | about $+8.7\%$ |
| Cobb-Douglas benchmark | Unit elasticity, moderate reallocation | $\varepsilon=1$ | about $+17.4\%$ |
| CES example with stronger substitution | Time shifts strongly toward the sped-up bundle | $\varepsilon=2$ | about $+40\%$ |

**The key empirical object is the share response to an effective price change.**
: The identification problem is not only how big $A$ is when AI is used, but how time shares respond when relative time prices change. In the CES benchmark that response is summarized by $\varepsilon$; outside CES, it is a demand-curve object.

**Endogenous task mix can make pre-AI shares a poor guide.**
: If AI reduces time costs more for tasks you previously avoided (high search/reading/writing overhead), then the pre-AI share $s_0$ understates the mass of tasks that become attractive post-AI.

**Quality adjustment matters whenever "time saved" is partly quality.**
: Some measured time savings are quality improvements (or vice versa). If your output index treats quality as part of output, you need a quality measure to map time changes into the output index $y(\cdot)$.

### Application 2: interpreting “uplift” RCTs (METR / open-source dev)

**Uplift RCTs often identify intensive effects on a fixed task set.**
: @becker2025uplift is an RCT where tasks are assigned to allow vs disallow AI tools, and the outcome is completion time (with additional self-reports and robustness checks). The headline is that AI access increases completion time on average in their setting.

**A simple back-of-envelope converts time changes into a productivity multiplier.**
: If allowing AI increases completion time by 19%, then the implied productivity multiplier is $A \approx 1/1.19 \approx 0.84$ (a slowdown). Holding output constant, that is about a 16% productivity hit on that task population.

**Fixed-task designs identify an $A_i$ distribution but not substitution.**
: With a fixed task set (as in many RCTs), the main object you learn is a task-level time change (an $A_i$ distribution if you convert time changes into productivity multipliers), holding task composition fixed. Mapping that into $V(A^1)/V(A^0)$ requires additional assumptions or variation that moves the task mix.

**Aggregate interpretations require an explicit output and quality index.**
: Translating time changes into an aggregate productivity index still requires an output/quality index: are we holding output constant (pure time saved), holding time constant (more output), or letting both adjust? In practice you often want quality-adjusted output per unit time.

**If AI changes which tasks are attempted, the design must measure selection.**
: If AI access changes which tasks are attempted, then the design has to either fix tasks (to isolate intensive effects) or explicitly allow selection and measure it (to capture the extensive margin).

## Experimental design

**Design choices mostly trade off identification of substitution against control of selection.**
: Designing studies that map $\{A_i\}$ into an aggregate lift $V(A^1)/V(A^0)$ is mostly about measuring substitution and separating intensive vs extensive margins.

**Decide the estimand before collecting data.**
: Same tasks, faster (hold task outputs fixed) is different from best use of a fixed time budget (maximize $y(A_1 t_1,\dots,A_n t_n)$). The latter matches the substitution estimand in this note.

**Use complementary protocols to separate intensive and extensive margins.**
: A simple way to separate margins is to run both a fixed-task and a time-budget protocol:

| Protocol | What is held fixed | What it identifies |
|---|---|---|
| Fixed-task protocol | A pre-specified task list | Task-level time/quality changes (intensive margin) |
| Time-budget protocol | A fixed time endowment and objective | Substitution and selection (task mix + output index) |

**Measure quality explicitly and specify how it enters the output index.**
: Use blinded human evaluation, unit tests, or objective metrics; pre-register how quality enters $y(\cdot)$ (e.g. threshold vs continuous scoring).

**Trace a demand curve by randomizing effective AI price/quality.**
: Randomize not only AI allowed, but the effective cost or strength of AI (token budgets, latency, model quality tiers, usage quotas). This gives variation to estimate how shares move with relative time prices (the object behind $\varepsilon$ or, more generally, Hicksian shares).

**Handle learning, spillovers, and dynamics.**
: Use cross-over designs, washout periods, or between-subject randomization where appropriate; measure experience and allow for dynamic treatment effects.

## Related literature (more explicit)

**This section is a reading map keyed to the objects used in the note.**
: The goal is to point to canonical references for price indices, time allocation, discrete activation, and empirical measurement, without mixing too much bibliographic detail into the thesis lines.

### Index numbers and exact welfare from price changes (continuous case)

**Expenditure-function cost-of-living indices.**
: @konus1939trueindex defines a cost-of-living index as the ratio of minimum expenditures needed to reach a fixed utility level at two price vectors. This is exactly the object $P(p)=e(p,1)$ (with time prices instead of money prices) that corresponds here to $V(A)=1/P(1/A)$ under homotheticity.

**Exact/superlative indices and share-weighted approximations.**
: @diewert1976exact formalizes when index numbers (including Tornqvist/Divisia-type log-share formulas) are exact for flexible functional forms and motivates using share-weighted log changes as a local approximation.

**Duality and productivity measurement via index numbers.**
: @caves1982indexnumbers is a central reference for exact index-number measurement of input, output, and productivity, and for the duality framing used in the continuous model here.

**Large changes and compensated-demand integrals.**
: @willig1976consumerssurplus and @hausman1981exact connect equivalent/compensating variation and consumer surplus to integrals of compensated demand, clarifying why large AI shocks call for area under Hicksian demand rather than constant-elasticity shortcuts.

**Demand systems for practical welfare calculations.**
: @deaton1980aids introduces AIDS, a workhorse integrable demand system used to estimate demand and welfare effects of price changes in practice.

### Time allocation, information costs, and "overhead" time

**Time allocation as a core economic problem.**
: @becker1965allocation frames time allocation as a core economic problem, and is a natural ancestor of treating task durations as time prices.

**Time requirements and shadow prices.**
: @deserpa1971time emphasizes that goods require time to consume/produce and develops shadow-price implications close to the time-price interpretation here.

**Information/search costs as a mechanism for time savings.**
: @stigler1961information treats costly search as central; empirically, many LLM speedups look like reductions in search/reading/writing overhead rather than reductions in core task time.

**Characteristics and implicit prices.**
: @lancaster1966consumer gives an alternative lens: tasks bundle characteristics (information, drafting, formatting, reasoning), and AI shifts the implicit prices of those characteristics.

### Discrete activation, selection, and welfare with lumpy choices

**Welfare tools for discrete choice.**
: @smallrosen1981welfare is a classic reference for welfare analysis with discrete choice, directly relevant for unit-demand tasks and activation thresholds.

**Applied discrete-choice estimation.**
: @train2003discretechoice is a standard applied reference for estimating random-utility/discrete-choice models when you want to quantify substitution and welfare.

### Task-based technological change and aggregation

**Task-based technological change.**
: @autor2003skill and @acemoglu2011handbook popularize task-based views of technology, conceptually aligned with treating tasks as goods with relative time prices.

**Small-shock share-weighted logic (Hulten-style).**
: @hulten1978growth is the backbone for why $\Delta\ln V\approx \sum_i t_i\,\Delta\ln A_i$ can be reasonable for small or broad shocks.

**Beyond small shocks: nonlinearities and large changes.**
: @baqaee2019macro is a canonical reference on nonlinearities and large shocks and connects directly to why large AI shocks motivate demand-curve integration and careful treatment of selection.

**Micro-to-macro aggregation from technology evidence.**
: @oberfield2021micro is a useful reference on linking micro evidence on technology to macro implications.

**CES as a workhorse benchmark.**
: @dixit1977monopolistic sits behind many closed-form substitution formulas, including the two-good CES benchmark used above.

### Empirical AI productivity and usage measurement

**Log-based time-savings evidence.**
: @anthropic2025estimatingproductivitygains illustrates the appeal (and limits) of measuring conditional time savings and baseline shares in observational usage data.

**Fixed-task RCT evidence.**
: @becker2025uplift exemplifies randomized access to AI tools with completion-time outcomes, highlighting the importance of quality measurement and task selection.

**Early gen-AI productivity evidence across settings.**
: @noy2023generative and @brynjolfsson2023generative are widely cited early studies with evidence on productivity and heterogeneity.

**Usage composition and task mix.**
: @chatterji2025chatgpt documents usage patterns and task composition for ChatGPT, relevant when the task mix is endogenous.

**Valuing time savings and digital services.**
: @varian2011economic and @collis2025welfare are representative of work valuing digital services and time savings, complementary to the demand-theory framing here.
