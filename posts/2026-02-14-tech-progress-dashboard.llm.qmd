---
title: "Technical Progress Dashboard for AI Impact Tracking"
date: 2026-02-14
draft: true
format: html
---


<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<script src="data/tech-progress-dashboard.llm/tpd-data.llm.js"></script>

## Overview

This dashboard tracks multi-domain technical progress (with emphasis on AI/ML and optimization) using a unified long-format panel, provenance metadata, and per-series log-linear trend fits. The rendered chart reads `window.TPD_DATA` from a generated local bundle so updates are reproducible and pipeline-driven.

## Data flow

```{mermaid}
flowchart TD
  A["seed-series.llm.csv<br/>manual + curated seed rows"] --> B["ingest_tech_progress_dashboard.py"]
  R["raw/*.csv<br/>downloaded source extracts"] --> B
  E["derived AI/ML trend indexes<br/>(Epoch growth-rate based)"] --> B
  B --> C["normalized-series.llm.csv<br/>canonical long-format panel"]
  B --> D["tpd-data.llm.js<br/>window.TPD_DATA bundle"]
  B --> L["ingest-log.llm.md"]
  D --> Q["2026-02-14-tech-progress-dashboard.llm.qmd"]
  Q --> V["Interactive Plotly dashboard + provenance table"]
```


<style>
#tpd-controls {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 12px;
  margin: 10px 0 18px;
}
.tpd-control {
  border: 1px solid #d6d6d6;
  border-radius: 8px;
  padding: 10px;
  background: #fafafa;
}
.tpd-control label {
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
}
.tpd-control select,
.tpd-control input {
  width: 100%;
}
#tpd-notes {
  font-size: 0.92rem;
  color: #444;
  margin: 6px 0 12px;
}
#tpd-plot {
  width: 100%;
  min-height: 520px;
}
#tpd-provenance {
  margin-top: 12px;
  width: 100%;
  border-collapse: collapse;
  font-size: 0.9rem;
}
#tpd-provenance th,
#tpd-provenance td {
  border: 1px solid #ddd;
  padding: 6px;
  text-align: left;
  vertical-align: top;
}
#tpd-provenance th {
  background: #f3f3f3;
}
</style>

<div id="tpd-plot"></div>
<div id="tpd-notes"></div>

<div id="tpd-controls">
<div class="tpd-control">
<label for="tpd-domain">Domain</label>
<select id="tpd-domain" multiple size="6"></select>
</div>

<div class="tpd-control">
<label for="tpd-metric-type">Metric type</label>
<select id="tpd-metric-type" multiple size="6"></select>
</div>

<div class="tpd-control">
<label for="tpd-frontier">Frontier scope</label>
<select id="tpd-frontier">
<option value="frontier_only">Frontier only</option>
<option value="frontier_plus_average" selected>Frontier + informative average</option>
<option value="average_only">Average only</option>
</select>

<label for="tpd-y-mode" style="margin-top:10px;">Y-value mode</label>
<select id="tpd-y-mode">
<option value="indexed" selected>Indexed (first visible year = 1)</option>
<option value="raw">Raw values</option>
</select>

<label for="tpd-y-scale" style="margin-top:10px;">Y-axis scale</label>
<select id="tpd-y-scale">
<option value="log" selected>Log scale</option>
<option value="linear">Linear scale</option>
</select>
</div>

<div class="tpd-control">
<label for="tpd-year-min">Start year</label>
<input id="tpd-year-min" type="number" />

<label for="tpd-year-max" style="margin-top:10px;">End year</label>
<input id="tpd-year-max" type="number" />

<label for="tpd-min-points" style="margin-top:10px;">Min points per series</label>
<input id="tpd-min-points" type="number" min="4" step="1" value="4" />
</div>

<div class="tpd-control">
<label for="tpd-search">Series name filter</label>
<input id="tpd-search" type="text" placeholder="e.g. genome, transistor, solar" />

<label style="margin-top:10px;">
<input id="tpd-show-fit" type="checkbox" checked />
Show log-linear trend fit
</label>
</div>
</div>

## Provenance (visible series)

<table id="tpd-provenance">
<thead>
<tr>
<th>Series</th>
<th>Domain</th>
<th>Type</th>
<th>Frontier class</th>
<th>Direction (displayed)</th>
<th>Points shown</th>
<th>Source</th>
<th>Provenance note</th>
</tr>
</thead>
<tbody id="tpd-provenance-body"></tbody>
</table>

<script>
const TPD_DATA = Array.isArray(window.TPD_DATA) ? window.TPD_DATA : [];

const controls = {
  domain: document.getElementById("tpd-domain"),
  metricType: document.getElementById("tpd-metric-type"),
  frontier: document.getElementById("tpd-frontier"),
  yMode: document.getElementById("tpd-y-mode"),
  yScale: document.getElementById("tpd-y-scale"),
  yearMin: document.getElementById("tpd-year-min"),
  yearMax: document.getElementById("tpd-year-max"),
  minPoints: document.getElementById("tpd-min-points"),
  search: document.getElementById("tpd-search"),
  showFit: document.getElementById("tpd-show-fit")
};

const notesEl = document.getElementById("tpd-notes");
const provenanceBody = document.getElementById("tpd-provenance-body");

function hasPlotly() {
  if (typeof Plotly === "undefined") {
    notesEl.textContent = "Plotly failed to load. Check network access or use a local Plotly bundle.";
    return false;
  }
  return true;
}

function uniqueSorted(arr) {
  return [...new Set(arr)].sort();
}

function populateMultiSelect(selectEl, values) {
  selectEl.innerHTML = "";
  values.forEach((value) => {
    const option = document.createElement("option");
    option.value = value;
    option.textContent = value;
    option.selected = true;
    selectEl.appendChild(option);
  });
}

function selectedValues(selectEl) {
  return [...selectEl.selectedOptions].map((o) => o.value);
}

function groupBySeries(rows) {
  const grouped = new Map();
  rows.forEach((row) => {
    if (!grouped.has(row.id)) grouped.set(row.id, []);
    grouped.get(row.id).push(row);
  });
  grouped.forEach((arr) => arr.sort((a, b) => a.year - b.year));
  return grouped;
}

function toLowerBetterValue(row) {
  if (row.value <= 0) return null;
  return row.direction === "higher_better" ? 1 / row.value : row.value;
}

function fitLogLinear(points) {
  const filtered = points.filter((p) => p.value_lb > 0);
  if (filtered.length < 2) return null;

  const xs = filtered.map((p) => p.year);
  const ys = filtered.map((p) => Math.log(p.value_lb));

  const n = xs.length;
  const xMean = xs.reduce((a, b) => a + b, 0) / n;
  const yMean = ys.reduce((a, b) => a + b, 0) / n;

  let num = 0;
  let den = 0;
  for (let i = 0; i < n; i += 1) {
    num += (xs[i] - xMean) * (ys[i] - yMean);
    den += (xs[i] - xMean) ** 2;
  }
  if (den === 0) return null;

  const b = num / den;
  const a = yMean - b * xMean;
  return { a, b };
}

function annualImprovementPercent(slope) {
  return (1 - Math.exp(slope)) * 100;
}

function makeDisplayPoints(points, yMode) {
  if (yMode === "raw") return points.map((p) => ({ year: p.year, y: p.value_lb }));
  const base = points[0]?.value_lb;
  if (!base || base <= 0) return [];
  return points.map((p) => ({ year: p.year, y: p.value_lb / base }));
}

function render() {
  if (!hasPlotly()) return;

  const domainSel = selectedValues(controls.domain);
  const typeSel = selectedValues(controls.metricType);
  const frontierSel = controls.frontier.value;
  const yMode = controls.yMode.value;
  const yScale = controls.yScale.value;
  const yearMin = Number(controls.yearMin.value);
  const yearMax = Number(controls.yearMax.value);
  const minPoints = Number(controls.minPoints.value);
  const search = controls.search.value.trim().toLowerCase();
  const showFit = controls.showFit.checked;

  const filteredRows = TPD_DATA
    .filter((row) => {
      if (!domainSel.includes(row.domain)) return false;
      if (!typeSel.includes(row.metric_type)) return false;
      if (row.year < yearMin || row.year > yearMax) return false;
      if (search && !row.name.toLowerCase().includes(search)) return false;

      if (frontierSel === "frontier_only" && row.frontier_class !== "frontier") return false;
      if (frontierSel === "average_only" && row.frontier_class !== "average") return false;

      return true;
    })
    .map((row) => ({
      ...row,
      value_lb: toLowerBetterValue(row),
      unit_lb: row.direction === "higher_better" ? `1 / (${row.unit})` : row.unit,
      direction_lb: "lower_better"
    }))
    .filter((row) => row.value_lb !== null);

  const bySeries = groupBySeries(filteredRows);

  const seriesToPlot = [...bySeries.values()].filter((rows) => rows.length >= minPoints);

  const traces = [];
  const provenanceRows = [];
  let rawUnitSet = new Set();

  seriesToPlot.forEach((rows) => {
    const first = rows[0];
    rawUnitSet.add(first.unit_lb);
    const fit = fitLogLinear(rows);
    const annualPct = fit ? annualImprovementPercent(fit.b) : null;
    const seriesLabel = annualPct === null
      ? first.name
      : `${first.name} (${annualPct.toFixed(1)}%/yr)`;

    const displayPoints = makeDisplayPoints(rows, yMode);
    if (!displayPoints.length) return;

    traces.push({
      type: "scatter",
      mode: "lines+markers",
      x: displayPoints.map((d) => d.year),
      y: displayPoints.map((d) => d.y),
      name: seriesLabel,
      hovertemplate:
        "<b>%{fullData.name}</b><br>Year: %{x}<br>Value: %{y:.4g}<extra></extra>"
    });

    if (showFit) {
      if (fit) {
        const xFit = rows.map((p) => p.year);
        const yFitRaw = xFit.map((x) => Math.exp(fit.a + fit.b * x));
        const yFit = yMode === "raw"
          ? yFitRaw
          : yFitRaw.map((v) => v / yFitRaw[0]);

        traces.push({
          type: "scatter",
          mode: "lines",
          x: xFit,
          y: yFit,
          name: `${seriesLabel} trend`,
          showlegend: false,
          line: { dash: "dot", width: 2 },
          hovertemplate:
            "<b>%{fullData.name}</b><br>Year: %{x}<br>Fitted: %{y:.4g}<extra></extra>"
        });
      }
    }

    provenanceRows.push({
      name: first.name,
      domain: first.domain,
      metricType: first.metric_type,
      frontierClass: first.frontier_class,
      direction: first.direction,
      transformed: first.direction === "higher_better",
      points: rows.length,
      sourceName: first.source_name,
      sourceUrl: first.source_url,
      note: first.direction === "higher_better"
        ? `${first.provenance_note} Display transformed as 1/value so lower is better.`
        : first.provenance_note
    });
  });

  const layout = {
    title: "Technical Progress Over Time",
    showlegend: false,
    xaxis: { title: "Year" },
    yaxis: {
      title: yMode === "indexed"
        ? "Indexed value (first visible year = 1, lower is better)"
        : "Raw value (lower-is-better transformed)",
      type: yScale
    },
    hovermode: "closest",
    margin: { l: 65, r: 20, t: 60, b: 110 }
  };

  Plotly.newPlot("tpd-plot", traces, layout, { responsive: true, displaylogo: false });

  const warnings = [];
  if (seriesToPlot.length === 0) {
    warnings.push("No series match current filters and minimum-point threshold.");
  }
  if (yMode === "raw" && rawUnitSet.size > 1) {
    warnings.push("Raw mode currently mixes multiple units. Use indexed mode for cross-series comparison.");
  }

  notesEl.textContent = warnings.length
    ? warnings.join(" ")
    : `${seriesToPlot.length} series shown. Trend fit uses log-linear regression by series.`;

  provenanceBody.innerHTML = "";
  provenanceRows.forEach((row) => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.name}</td>
      <td>${row.domain}</td>
      <td>${row.metricType}</td>
      <td>${row.frontierClass}</td>
      <td>lower_better</td>
      <td>${row.points}</td>
      <td><a href="${row.sourceUrl}" target="_blank" rel="noopener noreferrer">${row.sourceName}</a></td>
      <td>${row.note}</td>
    `;
    provenanceBody.appendChild(tr);
  });
}

(function init() {
  if (!TPD_DATA.length) {
    notesEl.textContent = "No dashboard data loaded. Rebuild data bundle with `python tools/ingest_tech_progress_dashboard.py`.";
    return;
  }

  const domains = uniqueSorted(TPD_DATA.map((d) => d.domain));
  const metricTypes = uniqueSorted(TPD_DATA.map((d) => d.metric_type));
  const years = TPD_DATA.map((d) => d.year);

  populateMultiSelect(controls.domain, domains);
  populateMultiSelect(controls.metricType, metricTypes);

  controls.yearMin.value = Math.min(...years);
  controls.yearMax.value = Math.max(...years);

  [
    controls.domain,
    controls.metricType,
    controls.frontier,
    controls.yMode,
    controls.yScale,
    controls.yearMin,
    controls.yearMax,
    controls.minPoints,
    controls.search,
    controls.showFit
  ].forEach((el) => el.addEventListener("input", render));

  render();
})();
</script>

## Notes on data quality

- Dashboard data is generated via `tools/ingest_tech_progress_dashboard.py` from canonical seed + derived series.
- AI/ML trend-index series sourced from Epoch growth-rate statements are model-based derived indexes (not raw point extracts).
- Several frontier series remain seed-level and should be replaced with direct machine-readable source pulls over time.
- All displayed series are transformed to **lower-is-better** (`1/value` for originally higher-is-better metrics).
- Because units differ across technologies, indexed mode is the main comparison mode.


This dashboard is built to support **forecasting and measuring AI's impact on technological progress** using a frontier-first lens.

## Scope choices

1. Goal: support forecasting and monitoring of AI-driven acceleration in technical efficiency trends.
2. Included domains: compute hardware, compute storage, energy, energy storage, biotech, agriculture, AI/ML, optimization algorithms, compression, and communications channels.
3. Included metric classes: cost efficiency, physical productivity, energy efficiency, training-scale indexes, algorithmic speed, compression efficiency, and channel efficiency.
4. Frontier rule: include frontier series by default; include average series when they are informative or frontier data is sparse.
5. Data inclusion threshold: at least 4 time points, direction-of-improvement defined, source URL recorded.
6. Fitting method: per-series log-linear fit on historical data (`log(value) = a + b * year`).
7. v1 excludes causal attribution and forecasting beyond observed history.
8. Data refresh path: rerun `python tools/ingest_tech_progress_dashboard.py` to regenerate normalized CSV, JS bundle, and ingestion log.
