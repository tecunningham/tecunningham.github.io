<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom Cunningham">
<meta name="dcterms.date" content="2026-01-26">
<meta name="description" content="Tom Cunningham blog">

<title>Notes on Separability of Preferences | Tom Cunningham – Tom Cunningham</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d5e7c60e6424aa6ccf163f01508596ce.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-12027453-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>
<script>window.MathJax = {
   loader: { load: ["https://cdn.jsdelivr.net/gh/sonoisa/XyJax-v3@3.0.1/build/xypic.js"]},
   tex: {packages: {'[+]': ['xypic','bm']},
         macros: {  bm: ["\\boldsymbol{#1}", 1],
                    ut: ["\\underbrace{#1}_{\\text{#2}}", 2],
                    utt: ["\\underbrace{#1}_{\\substack{\\text{#2}\\\\\\text{#3}}}", 3] }
   }
};
</script>
<style>
   h1 {  border-bottom: 8px solid #557;}
   h2 {  border-bottom: 1px solid #ccc;}
   .greyproof {
      background-color: #f5f5f5;
      padding: 1em;
      margin: 1em 0;
      border-radius: 4px;
   }
</style>
<script>window.MathJax = {
      tex: {
         macros: {
            bm: ["\\boldsymbol{#1}", 1],
            ut: ["\\underbrace{#1}_{\\text{#2}}", 2],
            utt: ["\\underbrace{#1}_{\\substack{\\text{#2}\\\\\\text{#3}}}", 3]
         }}};
</script>
<style>
.caption{
   text-align: center;
}
</style>
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta name="twitter:title" content="Notes on Separability of Preferences | Tom Cunningham">
<meta name="twitter:description" content="Tom Cunningham blog">
<meta name="twitter:image" content="tecunningham.github.io/posts/2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-1-1.png">
<meta name="twitter:image-height" content="500">
<meta name="twitter:image-width" content="508">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Tom Cunningham</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href=".././about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/testingham"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/tom-cunningham-a9433/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://tecunningham.github.io/index.xml"> <i class="bi bi-rss-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://scholar.google.com/citations?user=MDB_DgkAAAAJ"> 
<span class="menu-text">scholar</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Notes on Separability of Preferences</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 26, 2026</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
        
    </div>
<!-- main -->
<main class="content quarto-banner-title-block page-columns page-full" id="quarto-document-content">





<style>
/* p { text-indent: -2em; margin-left: 2em; } */
dl { margin-bottom: 0px; }
dt strong { font-weight: bold; text-decoration: underline; }
dd { margin-left: 60px; }
/* dl {
   display: grid;
   grid-template-columns: max-content auto;
   //  grid-auto-flow: row;
}

dt {
   grid-column-start: 1;
   width: 200px;
}

dd {
   grid-column-start: 2;
   padding-bottom: .5em;
} */
</style>
<dl>
<dt><strong>Currently we assume separability.</strong></dt>
<dd>
We allow utility to depend on the comparison, <span class="math inline">\(\delta\)</span>, and we assume the comparison affects each attribute in a separable way: <span class="math display">\[u(x,\delta)=f\left( v(x) + \sum_i x_i u_i(\delta)\right).\tag{1}\]</span>
</dd>
<dt><strong>We want to justify this assumption.</strong></dt>
<dd>
It’s not super-clear to the reader what role separability plays, &amp; whether we could make a weaker assumption on <span class="math inline">\(u(x,\delta)\)</span>. However over the summer I concluded that any weaker assumptions would get weird behaviour.
</dd>
<dt><strong>TODO: reconstruct reasoning why nonseparable model is unsatisfactory.</strong></dt>
<dd>
.
</dd>
<dt><strong>What are the testable implications of separability?</strong></dt>
<dd>
<ol type="1">
<li>There’s a ton of literature on separability in general.
<ol type="1">
<li>The most general condition is non-existence of a set of choices such that each attribute realization appears equally-often on LHS and RHS. Can think of this as cancelling rows in a Motzkin matrix.</li>
<li>The independence assumption is much more intuitive, but it is only sufficient for binary attributes and <span class="math inline">\(n\leq 4\)</span>.</li>
<li>Our condition is a bit more complicated than simple separability, it’s a type of pairwise separability. Graphical intuition: a set of choices on a cube will violate pairwise separability if projecting the choices onto each face gives a cycle on each face.</li>
</ol></li>
</ol>
</dd>
<dt><strong>Simplest condition: square cycle.</strong></dt>
<dd>
In the <span class="math inline">\(n=2\)</span> case we have: <span class="math display">\[u(x_1,x_2,\delta)=v(x_1,x_2)+u_x(x_1,\delta)+u_y(x_2,\delta).\]</span><br>
I <em>believe</em> the following inequalities will be inconsistent with this: <span class="math display">\[\begin{aligned}
  u(x_1,y_1,\delta) &amp;\succ u(x_2,y_1,\delta)\\
  u(x_2,y_2,\delta) &amp;\succ u(x_1,y_2,\delta)\\
  u(x_1,y_2,\delta') &amp;\succ u(x_1,y_1,\delta')\\
  u(x_2,y_1,\delta') &amp;\succ u(x_2,y_2,\delta'),
   \end{aligned}
   \]</span>
</dd>
</dl>
<p>proof: (unfinished) <span class="math display">\[\begin{aligned}
      v(x_1,y_1) - v(x_2,y_1) + u_x(x_1,\delta)-u_x(x_2,\delta) &amp;&gt; 0\\
      v(x_2,y_2) - v(x_1,y_2) + u_x(x_2,\delta)-u_x(x_1,\delta)  &amp;&gt; 0\\
      u(x_1,y_1,\delta') - u(x_1,y_2,\delta')&amp;&gt; 0\\
      u(x_2,y_2,\delta') - u(x_2,y_1,\delta')&amp;&gt; 0,
   \end{aligned}
   \]</span></p>
<dl>
<dt><strong>There exists a nice intuition for the cancellation condition.</strong></dt>
<dd>
The usual expression of the cancellation condition is fairly abstract: that there cannot exist a set of preferences in which each realization of each attribute appears equally often on left-hand-side and right-hand-side.
</dd>
</dl>
<p>There are some superior ways of explaining this:</p>
<ol type="1">
<li><p><strong>If the preferences are described in relative terms then they contain a cycle.</strong> E.g. suppose we observe these preferences: <span class="math display">\[\binom{north}{west} \succ \binom{south}{west},  \binom{south}{west} \succ \binom{north}{east},
   \binom{south}{east} \succ \binom{south}{west}
\]</span> We can write each in a <em>relative</em> style as follows: <span class="math display">\[North \succ South,\ \ \
   South+West \succ North+East, \ \ \
   East \succ West
\]</span> Alternatively we can avoid the additions and write this as: <span class="math display">\[v_{NS} &gt; 0,  \ \ \  v_{WE} &gt; v_{NS},  \ \ \  v_{WE} &lt; 0\]</span></p>
<p>We can also apply this to non-binary attributes, e.g.&nbsp; <span class="math display">\[\binom{3 lemons}{2 oranges} &gt; \binom{2 lemons}{3 oranges}\]</span> Can be rewritten as: <span class="math display">\[v(\text{3rd lemon}) &gt; v(\text{3rd orange})\]</span></p></li>
<li><p><strong>.</strong></p></li>
</ol>
<section id="more-notes" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="more-notes">more notes</h2>
<p><strong>Summary.</strong></p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 13%">
<col style="width: 18%">
<col style="width: 53%">
</colgroup>
<thead>
<tr class="header">
<th>observations</th>
<th>granularity</th>
<th>attributes</th>
<th>sufficient for additivity</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>incomplete</td>
<td>-</td>
<td>-</td>
<td>cancellation</td>
</tr>
<tr class="even">
<td>complete</td>
<td>continuous</td>
<td><span class="math inline">\(n=2\)</span></td>
<td>hexagon / double cancellation (Wakker, 1989)</td>
</tr>
<tr class="odd">
<td>complete</td>
<td>continuous</td>
<td><span class="math inline">\(n&gt;2\)</span></td>
<td>independence</td>
</tr>
<tr class="even">
<td>complete</td>
<td>binary</td>
<td><span class="math inline">\(n\leq 4\)</span></td>
<td>independence (Bradley et al., 2005)</td>
</tr>
<tr class="odd">
<td>complete</td>
<td>multinomial</td>
<td>-</td>
<td>cancellation (Tversky, 1964)</td>
</tr>
</tbody>
</table>
<p><strong>For two goods, additively separable if and only if <span class="math inline">\(\succeq\)</span> satisfies double cancellation.</strong><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> <span class="math display">\[\begin{aligned}
         (x1,y1) \succ (x2,y2) \\
         (x2,y3) \succ (x3,y1) \\
         \implies
         (x1,y3) \succ (x3,y2) \\
   \end{aligned}
   \]</span></p>
<div class="no-row-height column-margin column-container"><div id="fn1"><p><sup>1</sup>&nbsp;Pollison: <em>“Debreu (1960) shows that with only two goods … preferences can be represented by an additively separable utility function if and only if a double cancellation condition holds.”</em></p></div></div><p><strong>For <em>n</em> goods, additively separable if and only if <span class="math inline">\(\succeq\)</span> satisfies preferential independence.</strong> From Wikipedia:</p>
<p><span class="math display">\[(x_1,x_2,\bm{x}_3)\succeq (x'_1,x'_2,\bm{x}_3)
      \iff (x_1,x_2,\bm{x}'_3)\succeq (x'_1,x'_2,\bm{x}'_3)
   \]</span></p>
<p><strong>Q: how can it be that additively separable functions are unique only up to linear transforms?</strong> Oh it’s simple: any monotonic transform will still represent choice just as well, but that function won’t be additively separable. So among the subset of additively separable functions, they’re all linear transforms of each other.</p>
<p><strong>Note: we care about additive separability, not separability.</strong> In our case separability and additive separability are equivalent: Bergstrom theorem 2 shows that if every commodity is separable then they’re all additively separable.</p>
<p><strong>Q: topological vs algebraic approach?</strong> <span class="citation" data-cites="wakker1988algebraic">P. Wakker (<a href="#ref-wakker1988algebraic" role="doc-biblioref">1988</a>)</span> discusses this: topological essentially is using continuity and first-order conditions, and Debreu assumes continuity for his results. Algebraic is used by Krantz et al., while Wakker’s book uses topological.</p>
<p><strong>What we want: a necessary and sufficient condition for a finite space.</strong></p>
<ul>
<li><span class="citation" data-cites="wakker1989additive">P. P. Wakker (<a href="#ref-wakker1989additive" role="doc-biblioref">1989</a>)</span> has a brief discussion on p33, states a cancellation condition as necessary and sufficient: “with every <span class="math inline">\(z_j \in \Gamma_j\)</span> occurring equally often to the left of the preferences … as to the right of the preferences”</li>
<li>He later mentions Dana Scott (1964) who derives something about sets of inequalities but hard to follow.</li>
</ul>
</section>
<section id="conditions" class="level1 page-columns page-full">
<h1>Conditions</h1>
<section id="double-cancellation-thomsen" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="double-cancellation-thomsen">Double cancellation / Thomsen</h2>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-1_44cfa3006a6661dc19f1928f0cd86f92">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>violation of double cancellation</figcaption>
</figure>
</div>
</div></div></div>
<p><span class="math display">\[\begin{aligned}
         (x_1,y_2) \succ (x_2,y_1),
         (x_2,y_3) \succ (x_3,y_2)
         \implies
         (x_1,y_3) \succ (x_3,y_1)
   \end{aligned}
   \]</span></p>
<p><span class="citation" data-cites="wakker1988algebraic">(<a href="#ref-wakker1988algebraic" role="doc-biblioref">P. Wakker 1988</a>, p??)</span> gives the Thomsen condition (for <span class="math inline">\(n=2\)</span>) as: <span class="math display">\[(x_1,y_2)\sim (x_2,y_1), (x_2,y_3)\sim (x_3,y_2)
         \implies (x_1,y_3)\sim (x_3,y_1)\]</span></p>
<p>This is essentially double cancellation but with indifferences.</p>
</section>
<section id="hexagon-condition" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="hexagon-condition">Hexagon condition</h2>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-2_8d7ebf01242e1ebd8fc875f0b615baa5">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>Violation of Hexagon condition (Wakker 1989)</figcaption>
</figure>
</div>
</div></div></div>
<p><span class="citation" data-cites="wakker1989additive">P. P. Wakker (<a href="#ref-wakker1989additive" role="doc-biblioref">1989</a>)</span>, this version from <span class="citation" data-cites="karni1998hexagon">Karni and Safra (<a href="#ref-karni1998hexagon" role="doc-biblioref">1998</a>)</span>, for <span class="math inline">\(n=2\)</span>:</p>
<p><span class="math display">\[(x_1,y_2)\sim (x_2,y_1),
      (x_3,y_1)\sim (x_2,y_2)\sim (x_1,y_3)
      \implies
      (x_2,y_3)\sim (x_3,y_2)
   \]</span></p>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-3_21bb4cdadacf5dd18424e69617ceae32">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>Example ofrom Fishburn (1970) of choices that satisfy independence (because monotonic), but violate the hexagon condition, and therefore do not have a separable representation. These numbers can be generated by <span class="math inline">\(u(x,y)=xy+x^y\)</span>.</figcaption>
</figure>
</div>
</div></div></div>
<p>Karni and Safra say “the hexagon condition is … logically weaker than the Thomsen condition and the triple cancelation condition.” However they also give a Lemma that under independence and restricted solvability (continuity) then the hexagon condition will hold if and only if the Thomsen condition holds holds.</p>
</section>
<section id="triple-cancellation" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="triple-cancellation">Triple cancellation</h2>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-4_9d9cb4140b1bda4c5d2870b0a41c82d2">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>Violation of triple cancellation (Reidmeister)</figcaption>
</figure>
</div>
</div></div></div>
<p>From <span class="citation" data-cites="wakker1988algebraic">P. Wakker (<a href="#ref-wakker1988algebraic" role="doc-biblioref">1988</a>)</span>, says it’s for <span class="math inline">\(n=2\)</span>: <span class="math display">\[\begin{aligned}
      &amp; (x_2,y_1)\succeq (x_1,y_2),\\
      &amp; (x_3,y_2)\succeq (x_4,y_1),\\
      &amp; (x_1,y_4)\succeq (x_2,y_3)\\
      \implies &amp; (x3,y4)\succeq (x4,y3)
   \end{aligned}
   \]</span></p>
<p>Seems to also be known as “Reidmeister” condition. This seems to have a similarity with the “double reversal” condition in the case of binary attributes.</p>
</section>
<section id="mth-order-cancellation" class="level2">
<h2 class="anchored" data-anchor-id="mth-order-cancellation">mth-order cancellation</h2>
<p><span class="citation" data-cites="wakker1989additive">P. P. Wakker (<a href="#ref-wakker1989additive" role="doc-biblioref">1989</a>)</span> p34 says (…)</p>
</section>
<section id="independence" class="level2 page-columns page-full">
<h2 class="anchored" data-anchor-id="independence">Independence</h2>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-5_070fe18f9605d203f19689351bf019a6">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>Violation of independence.</figcaption>
</figure>
</div>
</div></div></div>
<p><span class="math display">\[(x_1,y_1,\bm{z}_1)\succeq (x_2,y_2,\bm{z}_1)
         \iff (x_1,y_1,\bm{z}_2)\succeq (x_2,y_2,\bm{z}_2)
      \]</span></p>
<p><span class="citation" data-cites="wakker1988algebraic">P. Wakker (<a href="#ref-wakker1988algebraic" role="doc-biblioref">1988</a>)</span> calls it “coordinate independence” and says “it is known by many names, such as (preferential) independence, additivity, strong (strict) separability, and the sure-thing principle.” Wakker writes it like this, which I think is basically equivalent:</p>
<p><span class="math display">\[(x_1,y_1)\succeq (x_2,y_1) \implies (x_1,y_2)\succeq (x_2,y_2)\]</span></p>
<p><span class="citation" data-cites="karni1998hexagon">Karni and Safra (<a href="#ref-karni1998hexagon" role="doc-biblioref">1998</a>)</span> define independence if <em>both</em> of these hold:</p>
<span class="math display">\[\begin{aligned}
      (x_1,y_1)\succ (x_2,y_1)
         \implies (x_1,y_1)\succ (x_2,y_1) \\
      (x_1,y_1)\succ (x_1,y_2)
         \implies (x_2,y_1)\succ (x_2,y_2) \\
   \end{aligned}\]</span>
<p>Note that monotonicity is sufficient for independence, but not necessary. If attributes are binary then monotonicity is both necessary and sufficient.</p>
<div class="cell page-columns page-full" data-hash="2023-10-27-notes-on-separability_cache/html/unnamed-chunk-6_2609deae5db0f9c3a56b06daca7c0326">

<div class="no-row-height column-margin column-container"><div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2023-10-27-notes-on-separability_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="192"></p>
<figcaption>Indirect/revealed violation of independence.</figcaption>
</figure>
</div>
</div></div></div>
</section>
</section>
<section id="references" class="level1 page-columns page-full">
<h1>References</h1>
<p><strong>Scott (1964) “Measurement Structures and Inequalities”</strong></p>
<p>Seems to be the first clear necessary &amp; sufficient condition for additive separability. See Theorem 3.1 and 3.2, he seems to derive it from Kuhn-Tucker conditions. The condition seems to be basically a sequence and a permutation.</p>
<p><strong>Gorman (1968) The structure of utility functions</strong></p>
<p>Bradley et al.&nbsp;say “Gorman’s (1968) second theorem [is] that separable [independent] preferences are additive.”</p>
<p><strong><span class="citation" data-cites="fishburn1970utility">Fishburn (<a href="#ref-fishburn1970utility" role="doc-biblioref">1970</a>)</span> <a href="https://apps.dtic.mil/sti/pdfs/AD0708563.pdf">“Utility Theory for Decision Making”</a></strong></p>
<ul>
<li>Chapter 4 “Additive Utilities with Finite Sets”. Derives cancellation condition from a Theorem of the Alternative, says it has been used for additive utility conditions by <span class="citation" data-cites="tversky1964additive">Tversky (<a href="#ref-tversky1964additive" role="doc-biblioref">1964</a>)</span>, Scott (1964), and Adams (1965).</li>
<li><em>Separability is not sufficient for additive utility.</em> Surprising because separability <em>is</em> sufficient in continuous spaces (with continuity). I think counterexample is a function that’s nonseparable, but you choose a set of discrete points where it’s separable. Thus as Wakker says you need to check a lot of cancellation conditions to see if the data fits.</li>
<li>Note: monotonicity is sufficient for separability.</li>
<li><em>Counterexample:</em> On p43: <span class="math inline">\(u(x1,x2)=x_1x_2+x_1^{y_1}\)</span>, with X1={1,2,3}, X2={1,3,5}. See image to the right.</li>
<li><em>Thm 4.1: ≽ has a separable utility function iff there is no set of choices where RHS attributes are permutations of LHS attributes</em> (he notes that Tversky calls this condition “cancellation”).
<ul>
<li>Formally: if you have <span class="math inline">\(x^j\succ y^j\)</span> for <span class="math inline">\(j=1,\ldots,m\)</span> then it can’t be that the attribute-values of <span class="math inline">\(x^j\)</span> are all permutations of the elements of <span class="math inline">\(y^j\)</span>.</li>
</ul></li>
</ul>
<p><strong><span class="citation" data-cites="krantz1971foundations">Krantz et al. (<a href="#ref-krantz1971foundations" role="doc-biblioref">1971</a>)</span> (KLST) (1971) “Foundations of Measurement”</strong> - People say it’s classic work.</p>
<p><strong><span class="citation" data-cites="wakker1988algebraic">P. Wakker (<a href="#ref-wakker1988algebraic" role="doc-biblioref">1988</a>)</span> <a href="https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=65ea16c5c59b80769fa5f3adfd8bbf0a8e1f783d">The Algebraic versus the Topological Approach to Additive Representations</a></strong></p>
<ul>
<li><blockquote class="blockquote">
<p>“This paper extends the additivity result from Krantz, Luce, Suppes &amp; Tversky (1971) to additionally show that the representation is continuous. This is obviously not necesary for our purposes.</p>
</blockquote></li>
<li><blockquote class="blockquote">
<p>“[the result shows] the algebraic approach of KLST to additive conjoint measurement is preferable to the more customary topological approach [of Debreu].</p>
</blockquote></li>
</ul>
<p><strong><span class="citation" data-cites="wakker1989additive">P. P. Wakker (<a href="#ref-wakker1989additive" role="doc-biblioref">1989</a>)</span> <em>Additive Representation of Preferences</em>.</strong></p>
<ul>
<li><em>Independence of equal subalternatives:</em> (…)</li>
<li><em>Coordinate independence</em>: <span class="math display">\[\forall i, [x_{-i}v_i\succeq y_{-i}v_i]\iff[x_{-i}w_i\succeq y_{-i}w_i]\]</span></li>
<li><em>Weak separability:</em> <span class="math display">\[\forall i, [v_{-i}x_i\succeq v_{-i}y_i]\iff [w_{-i}x_i\succeq w_{-i}y_i]\]</span></li>
<li><em>Separability with Finite Alternatives</em>
<ul>
<li>p33: when alternatives are finite then necessary &amp; sufficient that there’s no set of inequalities such that LHS adds to RHS. “with every <span class="math inline">\(z_j\in\Gamma_j\)</span> occurring equally often to the left of the preferences … as to the right of the preferences”</li>
<li>He then talks about this matching condition for a fixed list of alternatives <span class="math inline">\(m\)</span>. Says that this is what KLST call “mth-order cancellation”. Relates this to transitivity and first-order cancellation (?).</li>
<li><blockquote class="blockquote">
<p>“This result has been given in Scott(1964), Tversky(1964), KLST(Theorem 9.1), and Narens(1985, Theorems 5.2.1 and 5.2.2).. The latter two references also deal with noncomplete binary relations, compare Remark A3.4. Scott very clearly presents the general procedure to prove this, and many analogous, results.”</p>
</blockquote></li>
</ul></li>
<li>p34: The advantage of continuouos/topological spaces is that conditions are easier to check “they call on no more than one or two special cases of the above ‘cancellation’ axiom”.</li>
<li>Ch3: topological/continuous theorem. He describes hexagon condition.</li>
<li>p49, Central Theorem: if <span class="math inline">\(\succeq\)</span> is a continuous coordinate-independent weak order that satisfies the hexagon condition, then it can be represented with additive value functions.</li>
</ul>
<p><strong>Wakker (1991) “Additive Representations of Preferences, a New Foundation of Decision Analysis; The Algebraic Approach”</strong> - Says the paper adapts the 1989 model from topological to algebraic approach.</p>
<p><strong><span class="citation" data-cites="blackorby1998separability">Blackorby, Primont, and Russell (<a href="#ref-blackorby1998separability" role="doc-biblioref">1998</a>)</span> <a href="https://bpb-us-e1.wpmucdn.com/sites.psu.edu/dist/c/13885/files/2014/07/Blackorby1998_Separability-A-Survey.pdf">Separability: A Survey</a>.</strong> - Mostly about demand I believe.</p>
<p><strong><span class="citation" data-cites="karni1998hexagon">Karni and Safra (<a href="#ref-karni1998hexagon" role="doc-biblioref">1998</a>)</span> “The Hexagon Condition and Additive Representation for Two Dimensions: An Algebraic Approach”</strong></p>
<ul>
<li>They show that the hexagon condition is somewhat superior to Thomsen condition.</li>
</ul>
<p><strong><span class="citation" data-cites="bradley2005separable">Bradley, Hodge, and Kilgour (<a href="#ref-bradley2005separable" role="doc-biblioref">2005</a>)</span> “Separable Discrete Preferences”</strong></p>
<ul>
<li>They note that independence of <span class="math inline">\(\succ\)</span> is not sufficient for separability of <span class="math inline">\(u(.)\)</span> when the outcome space is discrete. Their counter-example is from Kraft (1959). Note that they use “separability” for our “independence,” and they use “additive” for our “separability.”</li>
<li>Weirdly they don’t seem to cite any theorem about necessary &amp; sufficient conditions for separability (i.e.&nbsp;KLST/Fishburn/Wakker).</li>
<li><em>Nice result! independence is sufficient for separability with binary dimensions and n&lt;=4.</em> (however our <span class="math inline">\(\delta\)</span> isn’t binary, if we’re going to consider that as a dimension)</li>
<li><em>Nice: when attributes are binary then separability implies linearly separability.</em> (proposition 5.3).</li>
<li><em>Mirror property:</em> If <span class="math inline">\(\succ\)</span> is separable then <span class="math inline">\(x\succ y\)</span> implies <span class="math inline">\(-y\succ -x\)</span>.</li>
<li><em>Fishburn pair:</em> This refers back to Fishburn (1970), they say condition C can be represented as a pair.</li>
<li>They enumerate all possible preference relations over binary spaces with <span class="math inline">\(n=1,2,3,4\)</span>.</li>
<li>They say at the end they think it’s only a <em>coincidence</em> that separability implies additivity for <span class="math inline">\(n&lt;=4\)</span> because there aren’t many cases. They say something like “they don’t expect a general proof.”</li>
<li><em>The counter-example for n=5:</em> from p343, see drawing at side. <span class="math display">\[\begin{aligned}
    (0,1,1,0,1) &amp;\succ (1,0,0,1,0)\\
    (1,0,0,0,1) &amp;\succ (0,1,1,0,0)\\
    (0,0,1,1,0) &amp;\succ (0,1,0,0,1)\\
    (0,1,0,0,0) &amp;\succ (0,0,1,0,1)
\end{aligned}
\]</span> I think the following is equivalent but slightly easier to get intuition: <span class="math display">\[\begin{aligned}
    (1,1,1,1,1) &amp;\succ (0,0,0,0,0)\\
    (0,0,0,1,1) &amp;\succ (1,1,1,1,0)\\
    (1,0,1,0,0) &amp;\succ (1,1,0,1,1)\\
    (1,1,0,1,0) &amp;\succ (1,0,1,1,1)
\end{aligned}
\]</span></li>
</ul>

<div class="no-row-height column-margin column-container"><div class="">
<p><img src="images/2023-10-27-13-22-39.png" class="img-fluid"></p>
</div></div><p><strong><span class="citation" data-cites="polisson2018lattice">Polisson (<a href="#ref-polisson2018lattice" role="doc-biblioref">2018</a>)</span></strong></p>
<ul>
<li><p><em>He gives a test for additive separability of demand choice</em> – he says that prior literature always assumed concavity of the elementary functions while he doesn’t assume concavity. He discusses demand but results seems applicable to any multiattribute choice.</p></li>
<li><p>Says that separability is computationally hard but <em>additive</em> separability is not computationally hard.</p></li>
<li><p>Regarding general separability (not additive): <em>“It is well-known that preferences are separable on X if (x,y)≽(x’,y) for some y implies (x,y’)≽(x’,y’) for all y’ … It is also know that if ≽ has a utility representation, then preferences are separable on X if and only if there exists some functions v:X→R and f:RxY→R, where f is increasing in its first argument, such that u(x,y)=f(v(x),y). Assuming differentiability, notice that the marginal rates of substitution between any two commodities in X are independent of the choice from Y.”</em></p></li>
<li><p>I’m confused as to how his result differs from Krantz/Fishburn/Wakker. I don’t think they assume concavity. I think perhaps the key difference is that he wants to construct a <em>continuous</em> utility function?</p></li>
</ul>
<p><strong>Wikipedia, <a href="https://en.wikipedia.org/wiki/Ordinal_utility">Ordinal Utility</a></strong>. Has good discussion of some separability results.</p>
<blockquote class="blockquote">
<p>An additive ordinal utility function is unique up to increasing linear transformation.</p>
</blockquote>
<p><strong>Bergstrom <a href="https://econ.ucsb.edu/~tedb/Courses/GraduateTheoryUCSB/separabilitynotes.pdf">Lecture Notes on Separable Preferences</a></strong>: Seems to be all in a continuous setup:</p>
<ul>
<li>Theorem 1: preferences are separable in <span class="math inline">\(i\)</span>: <span class="math display">\[(x_i,x_{-i})\succeq(x_i',x_{-i})\implies (x_i,x'_{-i})\succeq(x_i',x'_{-i})\]</span> if and only if you can write utility <span class="math inline">\(U(f(x_i),x_{-i})\)</span>.</li>
<li>Theorem 2: additively separable if and only if every subset is separable. Doesn’t include proof but refers to Debreu (1960), Fishburn (1970), and Krantz et al.&nbsp;(1971).</li>
<li>Theorem 3: with two commodities then utility is additive separability if and only if double cancellation holds.</li>
</ul>
<p><strong><span class="citation" data-cites="chambers2016revealed">Chambers and Echenique (<a href="#ref-chambers2016revealed" role="doc-biblioref">2016</a>)</span> “Revealed Preference”</strong></p>
<ul>
<li>Nothing directly applicable. I think they don’t have any direct theorem on separability of utility from multiattribute choice, only from <em>demand</em> (i.e.&nbsp;choice given prices).</li>
</ul>
<p><strong>Kreps (1988) “Notes on the Theory of Choice”</strong></p>
<ul>
<li>Has nothing directly applicable</li>
</ul>
</section>
<section id="definitions" class="level1">
<h1>Definitions</h1>
<ul>
<li><strong>Partial order.</strong> If:
<ol type="1">
<li>reflexive (<span class="math inline">\(a\succeq a\)</span>)</li>
<li>transitive (<span class="math inline">\(a\succeq b, b\succeq c \implies  a\succeq c\)</span>)</li>
<li>antisymmetric (<span class="math inline">\(a \succeq b \implies \neg (b\succeq a)\)</span>).</li>
</ol></li>
</ul>
</section>
<section id="bibliography" class="level1">
<h1>Bibliography</h1>
</section>
<section id="matrix-perspective" class="level1">
<h1>Matrix Perspective</h1>
<p><strong>Matrix condition: .</strong> Given some <span class="math inline">\(A\)</span> we know there exists <span class="math inline">\(x\)</span> such that <span class="math inline">\(Ax&gt;0\)</span> if and only if there is no <span class="math inline">\(y&gt;0\)</span> such that <span class="math inline">\(yA=0\)</span>. So we can</p>
<p><strong>Matrix condition and hexagon.</strong></p>
<p><span class="math display">\[\begin{aligned}
      \bmatrix{a &amp; b \\ \hline
            c &amp; d \\}
   \end{aligned}
   \]</span></p>
<p><span class="math display">\[\left[\begin{array}{ccc|ccc}
      x_1 &amp; x_2 &amp; x_3 &amp; y_1 &amp; y_2 &amp; y_3 \\ \hline
      . &amp; . &amp; . &amp; . &amp; . &amp; . &amp;
   \end{array}\right]
   \]</span></p>



</section>


<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents" role="doc-bibliography" id="quarto-bibliography"><h2 class="anchored quarto-appendix-heading">References</h2><div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-blackorby1998separability" class="csl-entry" role="listitem">
Blackorby, Charles, Daniel Primont, and R Robert Russell. 1998. <span>“Separability: A Survey.”</span> <em>Handbook of Utility Theory</em> 1: 51–92. <a href="https://bpb-us-e1.wpmucdn.com/sites.psu.edu/dist/c/13885/files/2014/07/Blackorby1998_Separability-A-Survey.pdf">https://bpb-us-e1.wpmucdn.com/sites.psu.edu/dist/c/13885/files/2014/07/Blackorby1998_Separability-A-Survey.pdf</a>.
</div>
<div id="ref-bradley2005separable" class="csl-entry" role="listitem">
Bradley, W James, Jonathan K Hodge, and D Marc Kilgour. 2005. <span>“Separable Discrete Preferences.”</span> <em>Mathematical Social Sciences</em> 49 (3): 335–53. <a href="https://www.sciencedirect.com/science/article/abs/pii/S0165489604000782">https://www.sciencedirect.com/science/article/abs/pii/S0165489604000782</a>.
</div>
<div id="ref-chambers2016revealed" class="csl-entry" role="listitem">
Chambers, Christopher P, and Federico Echenique. 2016. <em>Revealed Preference Theory</em>. Vol. 56. Cambridge University Press.
</div>
<div id="ref-fishburn1970utility" class="csl-entry" role="listitem">
Fishburn, Peter C. 1970. <em>Utility Theory for Decision Making</em>. Krieger NY.
</div>
<div id="ref-karni1998hexagon" class="csl-entry" role="listitem">
Karni, Edi, and Zvi Safra. 1998. <span>“The Hexagon Condition and Additive Representation for Two Dimensions: An Algebraic Approach.”</span> <em>Journal of Mathematical Psychology</em> 42 (4): 393–99.
</div>
<div id="ref-krantz1971foundations" class="csl-entry" role="listitem">
Krantz, David, Duncan Luce, Patrick Suppes, and Amos Tversky. 1971. <span>“Foundations of Measurement, Vol. I: Additive and Polynomial Representations.”</span>
</div>
<div id="ref-polisson2018lattice" class="csl-entry" role="listitem">
Polisson, Matthew. 2018. <span>“A Lattice Test for Additive Separability.”</span> <a href="https://ifs.org.uk/sites/default/files/output_url_files/WP201808.pdf">https://ifs.org.uk/sites/default/files/output_url_files/WP201808.pdf</a>.
</div>
<div id="ref-tversky1964additive" class="csl-entry" role="listitem">
Tversky, Amos Nathan. 1964. <em>Additive Choice Structures</em>. University of Michigan.
</div>
<div id="ref-wakker1988algebraic" class="csl-entry" role="listitem">
Wakker, Peter. 1988. <span>“The Algebraic Versus the Topological Approach to Additive Representations.”</span> <em>Journal of Mathematical Psychology</em> 32 (4): 421–35.
</div>
<div id="ref-wakker1989additive" class="csl-entry" role="listitem">
Wakker, Peter P. 1989. <em>Additive Representations of Preferences: A New Foundation of Decision Analysis</em>. Vol. 4. Springer Science &amp; Business Media.
</div>
</div></section><section class="quarto-appendix-contents" id="quarto-citation"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-2026" class="csl-entry quarto-appendix-citeas" role="listitem">
<span>“Notes on Separability of Preferences.”</span> 2026. January 26,
2026. <a href="https://tecunningham.github.io/posts/2023-10-27-notes-on-separability.html">tecunningham.github.io/posts/2023-10-27-notes-on-separability.html</a>.
</div></div></section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("tecunningham\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>