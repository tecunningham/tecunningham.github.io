<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Tom Cunningham">
<meta name="description" content="Tom Cunningham blog">

<title>How Technology Changes the Offense-Defense Balance | Tom Cunningham – Tom Cunningham</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-d5e7c60e6424aa6ccf163f01508596ce.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

<script type="text/javascript">

(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-12027453-1', 'auto');

ga('send', {
  hitType: 'pageview',
  'anonymizeIp': true,
});
</script>
<script>window.MathJax = {
   loader: { load: ["https://cdn.jsdelivr.net/gh/sonoisa/XyJax-v3@3.0.1/build/xypic.js"]},
   tex: {packages: {'[+]': ['xypic','bm']},
         macros: {  bm: ["\\boldsymbol{#1}", 1],
                    ut: ["\\underbrace{#1}_{\\text{#2}}", 2],
                    utt: ["\\underbrace{#1}_{\\substack{\\text{#2}\\\\\\text{#3}}}", 3] }
   }
};
</script>
<style>
   h1 {  border-bottom: 4px solid black;}
   h2 {  border-bottom: 1px solid #ccc;}
</style>
<script>window.MathJax = {
         loader: { load: ['[custom]/xypic.js'],
                     paths: {custom: 'https://cdn.jsdelivr.net/gh/sonoisa/XyJax-v3@3.0.1/build/'}},
      tex: {packages: {'[+]': ['xypic']},
         macros: {
            bm: ["\\boldsymbol{#1}", 1],
            ut: ["\\underbrace{#1}_{\\text{#2}}", 2],
            utt: ["\\underbrace{#1}_{\\substack{\\text{#2}\\\\\\text{#3}}}", 3]
         }}};
</script>
<style>
   h1 {  border-bottom: 4px solid black; }
   h2 {  border-bottom: 1px solid gray; padding-bottom: 0px; color: black; }
   dl {display: grid;grid-template-columns: max-content auto;}
   dt {grid-column-start: 1; width: 4cm;}
   dd {grid-column-start: 2; margin-left: 2em;}
</style>
<meta name="quarto:status" content="draft">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
<meta name="twitter:title" content="How Technology Changes the Offense-Defense Balance | Tom Cunningham">
<meta name="twitter:description" content="Tom Cunningham blog">
<meta name="twitter:image" content="tecunningham.github.io/posts/2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-1-1.png">
<meta name="twitter:image-height" content="702">
<meta name="twitter:image-width" content="1367">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Tom Cunningham</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href=".././about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/testingham"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://www.linkedin.com/in/tom-cunningham-a9433/"> <i class="bi bi-linkedin" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://tecunningham.github.io/index.xml"> <i class="bi bi-rss-fill" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://scholar.google.com/citations?user=MDB_DgkAAAAJ"> 
<span class="menu-text">scholar</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">How Technology Changes the Offense-Defense Balance</h1>
                      </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p>When a new technology emerges—better AI, faster networks, improved sensors—a natural question arises: will this help attackers or defenders more? The answer depends critically on the <strong>structure of the conflict</strong>, not just the technology itself.</p>
<p>I present four core mechanisms that determine which side benefits from technological improvement. Each mechanism has distinct logic and leads to different predictions.</p>
<section id="a-decision-framework" class="level1">
<h1>A Decision Framework</h1>
<p>To determine which side benefits from technology, ask three questions:</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Decision tree for predicting which side benefits from improved technology</figcaption>
</figure>
</div>
</div>
</div>
<p>The logic behind each branch:</p>
<dl>
<dt><strong>Finite search space.</strong></dt>
<dd>
When there’s a limited set of vulnerabilities to find, better search technology helps defense more—because eventually all holes are discovered, and the last one found determines the winner.
</dd>
<dt><strong>Can fix vs.&nbsp;must monitor.</strong></dt>
<dd>
If defense can permanently fix discovered vulnerabilities, they accumulate protection over time. If they can only monitor known vulnerabilities (with limited attention), attackers benefit as the known vulnerability set grows.
</dd>
<dt><strong>Ground truth vs.&nbsp;appearance.</strong></dt>
<dd>
If defense can verify items against ground truth (e.g., checking a document’s actual history), better classifiers help defense. If defense only sees appearances (e.g., does this essay “look” authentic?), better classifiers help offense optimize forgeries.
</dd>
</dl>
</section>
<section id="four-core-mechanisms" class="level1">
<h1>Four Core Mechanisms</h1>
<section id="mechanism-1-finite-search-space-defense-favored" class="level2">
<h2 class="anchored" data-anchor-id="mechanism-1-finite-search-space-defense-favored">Mechanism 1: Finite Search Space (Defense Favored)</h2>
<p>When both sides search for vulnerabilities in a <strong>finite space</strong>, improved search technology favors the defender.</p>
<dl>
<dt>The intuition.</dt>
<dd>
Imagine a wall with 100 holes. Both attacker and defender search for holes—attacker to exploit them, defender to plug them. Initially with limited search capability, attacker might find 20 holes and defender finds 15, leaving 5 exploitable gaps. But as search technology improves, both sides find more holes. Eventually all 100 holes are discovered. At that point, every hole is plugged, and the attacker has no advantage left.
</dd>
</dl>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>As search technology improves in finite space, defense wins</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt><strong>Example: Code vulnerability discovery.</strong></dt>
<dd>
Modern fuzzing tools help both attackers and defenders find bugs in code. But since any codebase has a finite number of bugs, as fuzzing improves, defenders find and fix more bugs over time. The vulnerability backlog shrinks, favoring defense.
</dd>
<dt>The key feature.</dt>
<dd>
<strong>Saturation.</strong> The search space is bounded, so improved search eventually exhausts it.
</dd>
</dl>
</section>
<section id="mechanism-2-attention-constraints-offense-favored" class="level2">
<h2 class="anchored" data-anchor-id="mechanism-2-attention-constraints-offense-favored">Mechanism 2: Attention Constraints (Offense Favored)</h2>
<p>When defense cannot fix vulnerabilities but must <strong>monitor</strong> them with limited attention, improved search favors the attacker.</p>
<dl>
<dt>The intuition.</dt>
<dd>
Imagine a growing city with many entry points. Defense can watch known entry points but has limited personnel. As search technology reveals more and more entry points, defense must spread their attention thinner across them. Meanwhile, the attacker only needs to find ONE unwatched entry point to succeed.
</dd>
</dl>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>As known attack surface grows, defense attention spreads thinner</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt><strong>Example: Network intrusion detection.</strong></dt>
<dd>
As networks grow more complex, security teams discover more potential attack vectors. But security personnel are limited—they can’t actively monitor every endpoint. Attackers benefit from the expanding attack surface.
</dd>
<dt>The key feature.</dt>
<dd>
<strong>Unbounded monitoring burden.</strong> The set of things to watch grows faster than the defense’s ability to watch them.
</dd>
</dl>
</section>
<section id="mechanism-3-verification-with-ground-truth-defense-favored" class="level2">
<h2 class="anchored" data-anchor-id="mechanism-3-verification-with-ground-truth-defense-favored">Mechanism 3: Verification with Ground Truth (Defense Favored)</h2>
<p>When defense can <strong>verify</strong> items against ground truth, improved classification technology favors the defender.</p>
<dl>
<dt>The intuition.</dt>
<dd>
Suppose you’re checking whether a diamond is real. You have a testing device that gives a signal. Real diamonds give signal 10, fake diamonds give signals from 0-8 (with noise). As your testing device improves, it becomes easier to distinguish fakes from genuine items. In the limit of perfect testing, no fake can pass.
</dd>
</dl>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Better classifiers with ground truth verification favor defense</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt><strong>Example: Document authentication.</strong></dt>
<dd>
Banks verify checks by comparing against actual account records. Better fraud detection systems (AI-powered signature verification, watermark detection) make it harder for forgers to succeed, because the bank can ultimately verify against ground truth.
</dd>
<dt>The key feature.</dt>
<dd>
<strong>Ground truth access.</strong> Defense can check against an external, objective standard that offense cannot fully replicate.
</dd>
</dl>
</section>
<section id="mechanism-4-examination-without-ground-truth-offense-favored" class="level2">
<h2 class="anchored" data-anchor-id="mechanism-4-examination-without-ground-truth-offense-favored">Mechanism 4: Examination without Ground Truth (Offense Favored)</h2>
<p>When defense only observes <strong>appearances</strong> without ground truth, improved classification technology can favor the attacker.</p>
<dl>
<dt>The intuition.</dt>
<dd>
Suppose you’re detecting whether a student wrote their own essay. You have a classifier that flags “AI-like” writing patterns. But “AI-like” is about appearance, not ground truth—you can’t actually verify whether the student used AI. As the classifier improves, students learn what patterns to avoid. Sophisticated AI tools can optimize text to avoid detection flags while still doing the work. The classifier helps offense optimize forgeries.
</dd>
</dl>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Better classifiers without ground truth can help offense optimize forgeries</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt><strong>Example: AI essay detection.</strong></dt>
<dd>
Essay detectors flag “AI-like” patterns, but they can’t verify ground truth (whether AI was actually used). As detectors improve, they reveal what patterns to avoid. AI tools are then trained to avoid these patterns, optimizing their forgeries. This is an arms race that structurally favors offense.
</dd>
<dt><strong>Example: Deepfakes.</strong></dt>
<dd>
Video authentication systems look for artifacts and inconsistencies. But they’re checking appearance, not ground truth. As detection improves, it reveals exactly what artifacts deepfake generators need to eliminate. Each generation of detectors trains the next generation of generators.
</dd>
<dt>The key feature.</dt>
<dd>
<strong>No ground truth, only signals.</strong> Defense’s improved classifier reveals information that offense can use to optimize forgeries. The classifier becomes a training signal for the attacker.
</dd>
</dl>
</section>
</section>
<section id="the-role-of-technology-speed" class="level1">
<h1>The Role of Technology Speed</h1>
<p>Even when technology structurally favors one side, the <strong>speed of technological change</strong> matters enormously.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>Rapid technological change favors offense (exploitation window grows)</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt>The logic.</dt>
<dd>
<strong>Patching takes time.</strong> When a new offensive capability emerges, there’s a window before defense adapts. If technology changes slowly, defense catches up and hardens systems. If technology changes rapidly, offense maintains a persistent advantage—each new capability arrives before the previous one is fully defended.
</dd>
<dt>This is why AI is particularly concerning.</dt>
<dd>
AI capabilities have been advancing rapidly—new model releases every few months, new exploitation techniques discovered continuously. Even in domains where technology structurally favors defense (like vulnerability finding), the rapid pace means offense may maintain an advantage in practice.
</dd>
<dt><strong>Example: Zero-day vulnerabilities.</strong></dt>
<dd>
When fuzzing tools improve gradually, security teams find and patch vulnerabilities at a steady pace. But when AI enables rapid discovery of novel exploit classes, the patching process can’t keep up. The theoretical advantage to defense (finite vulnerability space) is overwhelmed by the practical advantage to offense (rapid capability advancement).
</dd>
</dl>
</section>
<section id="phase-diagram-effort-and-equilibrium" class="level1">
<h1>Phase Diagram: Effort and Equilibrium</h1>
<p>We can visualize how improved technology shifts the equilibrium efforts of attackers and defenders.</p>
<p>Consider the “finding holes” scenario. Let <span class="math inline">\(e_A\)</span> be attacker effort and <span class="math inline">\(e_D\)</span> be defender effort. The probability attacker wins is: <span class="math display">\[P(\text{win}) = F(e_A) - F(e_D)\]</span> where <span class="math inline">\(F\)</span> is the cumulative probability of finding vulnerabilities.</p>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="2025-XX-XX-tech-offense-defense_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
<figcaption>As search technology improves (shifting F), equilibrium moves</figcaption>
</figure>
</div>
</div>
</div>
<dl>
<dt><strong>Key insight from the phase diagram.</strong></dt>
<dd>
In the finite search space model, as search technology improves: - Both sides exert <em>less</em> equilibrium effort (because search is cheaper) - But defense success rate <em>increases</em> dramatically - The marginal vulnerability becomes harder to find, and defense finds it first with high probability
</dd>
</dl>
<p>This is why the structure matters more than just “who benefits from better technology”—we need to understand the equilibrium dynamics.</p>
</section>
<section id="application-classifying-real-world-cases" class="level1">
<h1>Application: Classifying Real-World Cases</h1>
<p>Let’s apply the decision framework to classify some important cases:</p>
<section id="code-vulnerability-discovery" class="level2">
<h2 class="anchored" data-anchor-id="code-vulnerability-discovery">Code Vulnerability Discovery</h2>
<p><strong>Is search space finite?</strong> Yes—any codebase has finitely many bugs.</p>
<p><strong>Can defense fix holes?</strong> Yes—patches can permanently fix vulnerabilities.</p>
<p><strong>Prediction:</strong> Defense favored (Mechanism 1).</p>
<p><strong>Reality check:</strong> Fuzzing tools help both sides find bugs. Google’s OSS-Fuzz has found 10,000+ bugs in open-source projects, which are then fixed. The backlog of critical vulnerabilities in mature codebases has been declining, consistent with defensive advantage.</p>
</section>
<section id="spear-phishing-emails" class="level2">
<h2 class="anchored" data-anchor-id="spear-phishing-emails">Spear Phishing Emails</h2>
<p><strong>Is search space finite?</strong> No—unbounded space of convincing forgeries.</p>
<p><strong>Ground truth available?</strong> No—defender only sees appearance (does this email “look” legitimate?).</p>
<p><strong>Prediction:</strong> Offense favored (Mechanism 4).</p>
<p><strong>Reality check:</strong> AI makes it trivial to generate personalized, convincing phishing emails at scale. Email filters flag suspicious patterns, but attackers quickly adapt. This is an ongoing arms race where offense currently leads.</p>
</section>
<section id="ai-essay-detection" class="level2">
<h2 class="anchored" data-anchor-id="ai-essay-detection">AI Essay Detection</h2>
<p><strong>Is search space finite?</strong> No—unbounded space of essay variations.</p>
<p><strong>Ground truth available?</strong> No—detector only sees appearance (does this “look” AI-written?).</p>
<p><strong>Prediction:</strong> Offense favored (Mechanism 4).</p>
<p><strong>Reality check:</strong> GPTZero, Turnitin AI detector, and similar tools all face the same problem: as they improve, they reveal exactly what patterns to avoid. AI tools can be trained to evade detection. Detection accuracy has been declining as evasion methods improve.</p>
</section>
<section id="content-moderation-policy-violating-content" class="level2">
<h2 class="anchored" data-anchor-id="content-moderation-policy-violating-content">Content Moderation (policy-violating content)</h2>
<p><strong>Is search space finite?</strong> Effectively yes—there are finitely many ways to evade content policies.</p>
<p><strong>Can defense fix holes?</strong> Yes—patterns can be added to filters permanently.</p>
<p><strong>Prediction:</strong> Defense favored (Mechanism 1).</p>
<p><strong>Reality check:</strong> Platforms continuously improve content moderation. While new evasion tactics emerge, the overall trend has been toward better detection rates for policy violations. This is consistent with defensive advantage in a finite search space.</p>
</section>
<section id="deepfakes" class="level2">
<h2 class="anchored" data-anchor-id="deepfakes">Deepfakes</h2>
<p><strong>Is search space finite?</strong> No—unbounded space of synthetic media.</p>
<p><strong>Ground truth available?</strong> Partially—some provenance systems exist (C2PA), but most verification is appearance-based.</p>
<p><strong>Prediction:</strong> Currently offense favored (Mechanism 4), but could shift to defense with widespread provenance standards.</p>
<p><strong>Reality check:</strong> Deepfake quality is improving faster than detection. Each generation of detectors trains better generators. However, cryptographic provenance systems (content credentials) could shift this to defensive advantage by providing ground truth.</p>
</section>
</section>
<section id="summary" class="level1">
<h1>Summary</h1>
<p>Technology doesn’t uniformly help offense or defense—the structure of the conflict determines which side benefits.</p>
<p>Four key mechanisms:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 25%">
<col style="width: 22%">
<col style="width: 16%">
<col style="width: 35%">
</colgroup>
<thead>
<tr class="header">
<th>Mechanism</th>
<th>Key Feature</th>
<th>Technology Favors</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Finite search &amp; fixing</td>
<td>Exhaustible vulnerabilities</td>
<td><strong>Defense</strong></td>
<td>Code fuzzing, vulnerability scanning</td>
</tr>
<tr class="even">
<td>Finite search &amp; monitoring</td>
<td>Limited attention</td>
<td><strong>Offense</strong></td>
<td>Network intrusion, perimeter security</td>
</tr>
<tr class="odd">
<td>Verification (ground truth)</td>
<td>External validation</td>
<td><strong>Defense</strong></td>
<td>Document authentication, watermarking</td>
</tr>
<tr class="even">
<td>Examination (appearance)</td>
<td>No ground truth</td>
<td><strong>Offense</strong></td>
<td>Essay detection, deepfakes</td>
</tr>
</tbody>
</table>
<p>The speed of technological change creates an additional offensive advantage: rapid advancement prevents defense from catching up, even in structurally defensive domains.</p>
<p><strong>For policy and strategy:</strong> - In defensive domains (finite search, ground truth), invest in accelerating discovery and patching - In offensive domains (appearance-based), invest in provenance systems to create ground truth - In all domains, consider slowing the pace of capability advancement to allow defense time to adapt</p>
<p>The offense-defense balance is not fixed—it’s a design choice embedded in our institutions and technologies.</p>
</section>
<section id="references" class="level1">
<h1>References</h1>
<p>Key papers on offense-defense balance and conflict:</p>
<dl>
<dt>Garfinkel &amp; Skaperdas (2007) “Economics of Conflict: An Overview”</dt>
<dd>
Comprehensive review of contest models and conflict economics. Discusses how returns to scale affect equilibrium efforts.
</dd>
<dt>Garfinkel &amp; Dafoe (2019) “How does the offense-defense balance scale?”</dt>
<dd>
Argues that growth in investments tends to favor defense when investment levels are high.
</dd>
<dt>Glaser &amp; Kaufmann (1998) “What Is the Offense-Defense Balance and How Can We Measure It?”</dt>
<dd>
Defines the balance as the ratio of forces attacker needs relative to defender’s deployed forces.
</dd>
<dt>Schneier (2018) “Artificial Intelligence and the Attack/Defense Balance”</dt>
<dd>
Argues AI will favor defense because current attacks exploit human weaknesses that AI can shore up.
</dd>
<dt>Heather Adkins (2024) “The Offense-Defense Balance”</dt>
<dd>
Discusses how vulnerability discovery is accelerating with LLMs, with the key question being who runs faster at finding and fixing vulnerabilities.
</dd>
<dt>Bressler, Trager, Dafoe (2021) “The Offense-Defense Balance and the Costs of Anarchy”</dt>
<dd>
Shows that welfare can be better under high offensive advantage than intermediate levels, due to reduced conflict intensity.
</dd>
</dl>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("tecunningham\.github\.io");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>