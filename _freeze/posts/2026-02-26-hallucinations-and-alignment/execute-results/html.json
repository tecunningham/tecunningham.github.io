{
  "hash": "e8836a0f17e622a9477598f98fc49e7b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Knowledge of Success\ncitation: true\ndraft: true\nengine: knitr\nbibliography: ai.bib\n---\n\n\n<!-- - Note early on different terminology: \"abstain\", \"refuse\", \"reject\", \"IDK/i don't know\", \"forfeit\", \"concede\", \"fold\" (others?) -->\n\nLLMs are much more useful if they tell you their confidence.\n: \n    When asking an LLM to do a task it's reassuring to know that it's successful in some fraction of cases, but it's far more useful to know *which* cases it's successful in:\n\n    - If you're answering a question, I want to know your confidence in the answer.\n    - If you're supplying a proof for a theorem, I want to know whether you think the proof is valid.\n    - If you're fixing a bug, I want to know if you think the fix is going to work.\n    - If you're writing a poem for me, I want to know if the poem is good.\n\n    Unfortunately until recently LLMs were trained just to maximize their success rates, and for that reason they often wouldn't report useful signals of confidence, which made them much less useful. This I think is a good explanation of why LLMs hallucinate (argued in @kalai2025why), but the same logic illuminates some other cases.\n    \n    The discussion below mostly follows @kalai2025why, but adds some arguments and visualization I did when working with those authors in 2024 at OpenAI. I think these points are fairly well-known within the industry but ought to be better known outside it.\n\nThis follows from a very simple model.\n: \n    Suppose I have to make a choice among $N$ options, and I have no priors about which is most likely to be right. Then it's fine if the LLM just tells me which is the most-likely option, without telling me its probability.\n    \n    However if we add a touch of realism, then it suddenly becomes much more useful if the LLM tells me its probability (or it admits when it doesn't know). This will happen if any of the following are true: (1) I have some private information about the different options; (2) I can choose to spend some time verifying the proposed option, or searching for solutions; (3) I have the option of abstaining and not making a choice.\n    \n\nSome implications.\n: \n    1. **Models seem overconfident because they are trained only on accuracy, not on calibration.** When models aren't allowed to fold they learn to bluff.\n    2. **The value of a model will be a convex in its accuracy.** Going from 90% to 100% accuracy is more than twice as valuable as going from 80% to 90%, because it lowers the cost of verification, and lowers the likelihood of abstention. This is only true when models don't report their confidence.\n    3. **Benchmarks should report both accuracy and reliability.** If you're choosing betwen two models it's useful to know not just the share of correct responses, but also whether the model will report when it fails (i.e. accuracy).\n    4. **Models are good self-critics.** Somewhat surprisingly, a model can often identify its own mistakes. This makes sense for models that are trained only on accuracy, not on calibration, because they systematically exaggerate their success.\n\nIn this post.\n: \n    I state the model very briefly and give a nice visual aid, to show the optimal threshold for abstaining.\n    \n    I also show how we can use a simplex diagram to illustrate tradeoffs between accuracy and confidence, showing both the frontier (plotting results from benchmarks) and .\n\n<!-- \n- Related: implicit goals vs explicit goals.\n- Related: soft verification vs hard verification.\n- Related: models audit themselves, because they *know* whether they succeeded, so can easily see whether it's a success. \n- If you don't let the model fold then it will bluff.\n -->\n\n\n# Model\n\nBasic model: you just care about accuracy.\n: \n    Suppose you have to choose which of $N$ options is correct, you get $u=1$ if you succeed and $u=0$ if you fail. You have no idea which is right (uniform priors), but you know the LLM has information, and chooses the right answer with probability $p$. In this case it's sufficent for the LLM to report the option with the highest probability, and the user's expected payoff is linear in the LLM's average accuracy, $p$.\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-1-1.png){width=384}\n    :::\n    :::\n\n\n\n\nIf you can abstain, payoff is convex in accuracy.\n: \n    Now suppose the user can choose to abstain, i.e. they refuse to make a choice and get $u=\\pi_i$, with $0<\\pi_a<1$. Then they will only consult the model if $p>\\pi_a$, and so the value of the model will be convex in $p$. The threshold here is the same as that derived in @chow1970optimum.\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-2-1.png){width=384}\n    :::\n    :::\n\n\n\nIf there is costly verification then payoff will be three-part.\n: \n    Finally, now assume you can pay a cost $c$ to verify whether an answer is correct, and if it's wrong then you abstain. Then there will be three regions:\n    \n    - If $p$ is low, you don't ask the LLM, and abstain.\n    - If $p$ is intermediate you ask but verify (and abstain if it's wrong).\n    - If $p$ is high then you ask and trust without verification.\n\n\n\n    ::: {.cell}\n    ::: {.cell-output-display}\n    ![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-3-1.png){width=384}\n    :::\n    :::\n\n\n\n<!-- TO ADD: (1)  -->\n\n\n# Simplex Representation\n\nIt's very useful to draw the likelihood of three outcomes (succeed, fail, abstain) on a diagram.^[Economists know this as a Marschack-Machina diagram.] We can then draw indifference curves represnting different objective functions:\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\n\nEach point in the simplex is a lottery over outcomes: a model might succeed with probability $p_s$, fail with probability $p_f$, and abstain with probability $p_a$. The panels show three different objective families:\n\n- **Accuracy-only** ($U=p_s$): success is rewarded, but failure and abstention are treated the same. This creates pressure to guess rather than abstain.\n- **Penalize failure** (linear expected utility): failure is explicitly penalized relative to abstention, expanding the region where abstaining is optimal.\n- **F1** (a non-linear metric): indifference curves bend, reflecting that the metric itself builds in a particular tradeoff between attempting and being correct.\n\n\n### SimpleQA\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\n\n### Abstain-QA\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\n\n### Reading the simplex plots\n\n1. The horizontal axis is $p_s$ (succeed share) and the vertical axis is $p_f$ (fail share). The remaining probability is $p_a=1-p_s-p_f$ (abstain share), so points closer to the diagonal edge have lower abstention.\n\n2. Moving down (lower $p_f$) corresponds to reducing failures; whether that is best depends on how much worse failure is than abstention ($\\pi_f$ vs $\\pi_a$).\n\n3. The labeled points illustrate that a model can look good under an \"answer-everything\" regime by pushing $p_a$ toward zero, but that is exactly the regime that a payoff function with a harsh $\\pi_f$ would discourage.\n\n4. Don't over-interpret cross-benchmark comparisons: each source defines abstention differently, so these plots are best read as a geometric visualization of tradeoffs, not as a single unified leaderboard.\n\n\n\n#           Related Literature\n\n## Chronological sketch\n\n- @chow1970optimum: introduces the Bayes-optimal reject option (\"indecision\") and derives the posterior-threshold rule.\n- @herbei2006reject: formalizes \"classification with a reject option\" in modern statistical learning terms; there are many followups on learning and using reject policies (e.g. [@bartlett2008reject; @elyaniv2010selective; @geifman2019selectivenet]).\n- @kadavath2022mostly: finds that language models can often estimate whether their own answers are correct, which is exactly the signal needed to implement a threshold rule in practice.\n- Recent LLM work tries to *implement* the missing abstain/verify channel via refusal-aware tuning and explicit \"IDK\" tokens [@zhang-etal-2024-r; @cohen2024idontknowexplicit], verification loops [@dhuliawala2023chainofverificationreduceshallucinationlarge; @altinisik2026doireallyknow], and black-box uncertainty proxies like sampling-based checks or semantic uncertainty [@manakul-etal-2023-selfcheckgpt; @farquhar2024detectinghallucinationssemanticentropy].\n- @kalai2025why: argues LLM hallucinations are a predictable consequence of binary grading that penalizes abstention; proposes a scoring rule that makes abstaining optimal below a stated confidence threshold.\n\n### Chow (1970): Optimal reject rules\n\n@chow1970optimum introduces the **reject option** (which he calls the \"Indecision class\" $I$) into pattern recognition and derives the optimal error-reject tradeoff. Chow's terminology maps directly onto ours:\n\n| Chow's term | Our term |\n|---|---|\n| correct recognition | succeed |\n| error (misclassification) | fail |\n| rejection / indecision | abstain |\n\nChow's setup adds a third action (reject) to ordinary classification. In one common normalization, the costs are $0$ for a correct classification, $1$ for an error, and $t$ for a rejection.\n\nThe key result (\"Chow's rule\") is a posterior-threshold rule: accept and classify when confident enough, otherwise reject:\n$$\n\\max_i P(G_i \\mid x) \\ge 1-t\n\\quad\\Rightarrow\\quad \\text{accept;}\n\\qquad\n\\max_i P(G_i \\mid x) < 1-t\n\\quad\\Rightarrow\\quad \\text{reject.}\n$$\n\nIt is optimal in the sense that, for a given rejection threshold (equivalently, a given reject rate), no other rule achieves a lower error rate.\n\nThe threshold $t$ is related to the costs of the three outcomes as $t = (C_r - C_c)/(C_e - C_c)$, where $C_e, C_r, C_c$ are the costs of error, rejection, and correct recognition. In our payoff notation $(\\pi_s,\\pi_f,\\pi_a)$, Chow's rule becomes: predict iff\n\n$$\n\\max_y P(y \\mid x) \\ge \\frac{\\pi_a - \\pi_f}{\\pi_s - \\pi_f}.\n$$\n\nIn the Marschak-Machina triangle, this threshold corresponds to one of the indifference lines: the boundary between the region where prediction is preferred and the region where abstention is preferred.\n\n## Herbei and Wegkamp (2006) and followups: Learning a reject option\n\n@herbei2006reject (and a large followup literature) reframes the reject option as a learning problem: you want a predictor that is accurate on the examples it attempts, while explicitly controlling how often it refuses.\n\nFor this post, the key takeaway is less about any one algorithm and more about the framing: \"abstention is a first-class action\" is standard in the statistical decision-theory literature, and the same expected-utility thresholds show up once you make the third outcome explicit.\n\n## Kadavath et al. (2022): Models can sometimes score their own answers\n\nIf you want the simple $p^*$ rule to be usable, you need some per-question measure of correctness probability (like $p_{\\max}(x)$ or a direct $P(\\text{correct}\\mid x)$ proxy).\n\n@kadavath2022mostly study this in language models, finding that they can often estimate whether their own answers are correct. That makes \"give the user a probability\" a practical interface choice, not just a theoretical one.\n\n## Kalai, Nachum, Vempala, and Zhang (2025): Why language models hallucinate\n\n@kalai2025why argue that hallucinations are not a mysterious glitch but a predictable consequence of how models are trained and evaluated. Their central thesis is that the three-outcome structure (succeed, fail, abstain) is systematically distorted by binary evaluation:\n\nThe paper makes two distinct arguments:\n\n**1. Pretraining origin.** Even with error-free training data, the statistical objective of pretraining produces hallucinations. The authors reduce the problem to binary classification (\"Is-It-Valid\"), showing that\n\n$$\n\\text{generative error rate} \\gtrsim 2 \\cdot \\text{IIV misclassification rate}.\n$$\n\nFor arbitrary facts (like someone's birthday) where there is no learnable pattern, the hallucination rate after pretraining is at least the fraction of facts appearing exactly once in the training data.\n\n**2. Post-training persistence.** Even after RLHF and other interventions, hallucinations persist because nearly all evaluation benchmarks use binary grading that penalizes abstention:\n\nThe fix they propose is exactly the payoff structure from our Marschak-Machina framework: penalize errors more than abstentions, with an explicit confidence threshold $t$ stated in the prompt. Their proposed scoring rule awards $+1$ for a correct answer, $-t/(1-t)$ for an incorrect answer, and $0$ for abstaining---so that answering is optimal iff confidence exceeds $t$. This is Chow's reject-option rule rediscovered in the LLM evaluation context.\n\n## Recent mechanisms: refusal, uncertainty signals, and verification\n\nOur model is deliberately abstract: it assumes the user has access to (i) a usable confidence signal $p$ and (ii) an abstain / verify channel. A lot of recent work can be read as ways of engineering those two ingredients:\n\n- **Make abstention an explicit output.** Refusal-aware fine-tuning can teach a model to say \"I don't know\" on out-of-knowledge questions [@zhang-etal-2024-r]. Similarly, adding an explicit uncertainty token and training it to soak up probability mass on incorrect predictions effectively adds an abstain action to the model's output space [@cohen2024idontknowexplicit].\n\n- **Pay a cost to verify.** Inference-time verification loops like Chain-of-Verification (CoVe) can be viewed as \"spend extra tokens/compute to reduce $p_f$\" [@dhuliawala2023chainofverificationreduceshallucinationlarge]. Very recent work trains this kind of behavior directly, with structured self-verification traces and an explicit final decision to answer vs abstain [@altinisik2026doireallyknow].\n\n- **Construct a confidence signal without logits.** When output probabilities are unavailable (or untrustworthy), disagreement across samples can act as a proxy confidence signal. SelfCheckGPT does this with sampling-based consistency checks [@manakul-etal-2023-selfcheckgpt]; semantic-uncertainty methods like semantic entropy similarly use semantic variability across generations to predict and filter confabulations [@farquhar2024detectinghallucinationssemanticentropy], and followup work proposes cheaper \"semantic entropy probes\" in the same spirit [@kossen2024semanticentropyprobesrobust].\n\nA cautionary note: neither uncertainty proxies nor \"self-verification\" are automatically reliable. Some hallucinations happen with high confidence (so uncertainty-based filters can miss them) [@simhi2025trustmeimwrong], and in logical reasoning settings models can struggle to identify their own errors (so internal self-checks can fail without external grounding) [@hong-etal-2024-closer].\n\nBeyond factual QA, @mohamadi2025honestyaccuracytrustworthylanguage show on GSM8K/MedQA/GPQA that replacing binary RLVR rewards with a ternary scheme $(+1,0,-\\lambda)$ produces controllable answer-vs-abstain tradeoffs and useful abstention-aware cascades. @jha2026rewardingintellectualhumilitylearning report on MedMCQA and Hendrycks Math that moderate abstention rewards reduce wrong answers without collapsing coverage, especially when paired with supervised abstention training. In code generation, @dai2025reducinghallucinationsllmgeneratedcode frame the task as \"find a correct program or abstain\" and use semantic triangulation to improve abstention decisions on LiveCodeBench/CodeElo. Complementarily, @oehri2025trusteduncertaintylargelanguage fuse multiple uncertainty signals into calibrated correctness probabilities and enforce user-specified risk budgets via refusal, including experiments on code generation with execution tests.\n\n\n# Appendix: Verification option {#appendix-verification}\n\nSuppose the user has a way to pay a cost $c$ to obtain the correct answer (e.g. look it up, run an expensive check, ask a human). In the simplest model, verification yields certain success with payoff $\\pi_s-c$.\n\nSince abstaining and verifying are both \"outside options\" (their payoff does not depend on the model's confidence), the only relevant outside-option payoff is\n$$\n\\pi_{\\text{outside}}=\\max\\{\\pi_a,\\;\\pi_s-c\\}.\n$$\n\nThe attempt rule is the same threshold logic as before: attempt iff\n$$\np \\ge \\frac{\\pi_{\\text{outside}}-\\pi_f}{\\pi_s-\\pi_f}.\n$$\n\nIn the example shown below, $(\\pi_s,\\pi_a,\\pi_f)=(2,0,-2)$ and $\\pi_s-c=1$, so\n$$\np^*_{\\mathrm{verify}}=\\frac{1-(-2)}{2-(-2)}=\\tfrac{3}{4}.\n$$\n\nOperationally, \"verify\" can mean many things: a web lookup, a separate fact-checking model, retrieval + citation, or even a structured self-checking loop that spends extra tokens before committing to an answer [@dhuliawala2023chainofverificationreduceshallucinationlarge; @altinisik2026doireallyknow].\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](2026-02-26-hallucinations-and-alignment_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n## Appendix: Cross-Benchmark Outcome Table\n\nTo make cross-model plotting easier, the table below standardizes outputs from multiple benchmarks into a common schema.\n\n| benchmark | model | p_s_pct | p_f_pct | p_a_pct |\n|---|---|---:|---:|---:|\n| SimpleQA | Claude-3-haiku (2024-03-07) | 5.1 | 19.6 | 75.3 |\n| SimpleQA | Claude-3-sonnet (2024-02-29) | 5.7 | 19.3 | 75.0 |\n| SimpleQA | Claude-3-opus (2024-02-29) | 23.5 | 36.9 | 39.6 |\n| SimpleQA | Claude-3.5-sonnet (2024-06-20) | 28.9 | 36.1 | 35.0 |\n| SimpleQA | GPT-4o-mini | 8.6 | 90.5 | 0.9 |\n| SimpleQA | GPT-4o | 38.2 | 60.8 | 1.0 |\n| SimpleQA | OpenAI o1-mini | 8.1 | 63.4 | 28.5 |\n| SimpleQA | OpenAI o1-preview | 42.7 | 48.1 | 9.2 |\n| Abstain-QA | GPT-4 Turbo | 66.1 | 19.7 | 14.2 |\n| Abstain-QA | GPT-4 32K | 72.0 | 19.1 | 8.9 |\n| Abstain-QA | GPT-3.5 Turbo | 61.1 | 37.4 | 1.5 |\n| Abstain-QA | Mixtral 8x7b | 54.1 | 37.0 | 8.9 |\n| Abstain-QA | Mixtral 8x22b | 59.0 | 29.1 | 11.9 |\n\nNotes:\n- Table columns are constructed to look like probabilities in the $(p_s,p_f,p_a)$ simplex: $p_s=\\text{p\\_s\\_pct}/100$, $p_f=\\text{p\\_f\\_pct}/100$, $p_a=\\text{p\\_a\\_pct}/100$.\n- For SimpleQA, these correspond directly to {Correct, Incorrect, Not attempted} shares.\n- For Abstain-QA, these are constructed from the paper's summary metrics; interpret them as a mapping into a common coordinate system, not as identical underlying evaluation protocols.\n\n### Data extraction details by source\n\n**SimpleQA (Wei et al., 2024) [@wei2024measuringshortformfactualitylarge].**\nThe table uses all model rows shown in the main SimpleQA model-comparison table (8 models). Here, `p_s_pct` is **Correct**, `p_a_pct` is **Not attempted**, and `p_f_pct` is computed as $100-\\text{Correct}-\\text{Not attempted}$. I chose this slice because it is the paper's canonical cross-model summary and directly exposes explicit non-attempt behavior.\n\n**Abstain-QA (Madhusudhan et al., 2024) [@madhusudhan2024llmsknowanswerinvestigating].**\nThis is a deliberate subset, not all values in the paper: I take the **MMLU / Standard clause / Base** rows (5 models) from the main result table. The paper reports **AAC** (answerable accuracy) and **AR** (abstention rate). I set $p_{a,\\%}=\\text{AR}$ and construct $p_{s,\\%}$ and $p_{f,\\%}$ by treating AAC as attempt-conditional accuracy:\n$$\np_s = \\text{AAC}\\cdot(1-p_a),\\qquad\np_f = (1-\\text{AAC})\\cdot(1-p_a),\n$$\nall expressed in percent.\n\n**Important comparability caveats.**\nEven after mapping all results into $(p_s,p_f,p_a)$ coordinates, the underlying tasks and abstention protocols differ: SimpleQA is short-form factual QA with optional non-attempts, while Abstain-QA is multiple-choice QA with an explicit IDK/NOTA option. So the combined table is useful for geometric intuition and directional comparisons, but not for strict leaderboard ranking across benchmarks.\n\nSources: @wei2024measuringshortformfactualitylarge; @madhusudhan2024llmsknowanswerinvestigating.\n\n## Appendix: Benchmark Points in the Simplex\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}